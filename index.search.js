var relearn_search_index = [
  {
    "content": "In this section we will show\n",
    "description": "Simple examples of linear models.",
    "tags": null,
    "title": "Basic Linear Models",
    "uri": "/inla/basicoperationalinfo/linearmodels/index.html"
  },
  {
    "content": "In this part we will show different basic functions and operations, which are the basis to modeling with INLA.\nBasic Linear ModelsSimple examples of linear models.\nStacksA short introduction to inla stacks and their uses.\nMesh ConstructionBrief introduction to the construction of meshes: applications and operational basis.\nAdvanced FeaturesA short introduction to INLA advanced features and their uses.\n",
    "description": "A list of the basic operations that can be perform in R-INLA package.",
    "tags": null,
    "title": "Basic Operations",
    "uri": "/inla/basicoperationalinfo/index.html"
  },
  {
    "content": "",
    "description": "Simulated Dirichlet data fitted with a fixed effects model.",
    "tags": null,
    "title": "Example with fixed effects",
    "uri": "/inla/extensions/dirinla/linear_effects/index.html"
  },
  {
    "content": "Introduction In this GitHub Page it will exposed different questions related to Bayesian statistics and modeling with a double purposse. Firstly, as a way of organizing material that I am developing throughout different projects and the PhD Degree. Secondly, as a possible help for those interested in this field, in case this material has any value for it.\nThe main topics that would be found here will be related to:\nINLA (Integrated Nested Laplace Approximation) and inlabru MCMC (Markov Chain Monte Carlo) Hierarchical modeling Spatial modeling Temporal modeling Spatio-temporal modeling Shiny applications In order to adhere to a methodology in which the replicability and reproduction of the results obtained is absolutely mandatory, the version of the programming language, the programming environment for that language, along with the code and data used, are indicated at the beginning of each section. However, this alone may often be insufficient, so depending on the implemented code, it may be required to indicate the version of packages or libraries used in each case.\nAbout me Summary A picture My name is Mario Figueira and I am a PhD student in Statistics and Optimization at the University of Valencia, specifically my line of research focuses on spatio-temporal Bayesian modeling. ",
    "description": "",
    "tags": null,
    "title": "Home",
    "uri": "/index.html"
  },
  {
    "content": "INLA methodology There are various methodologies for the computational implementation of Bayesian inference, simulation methods such as MCMC (Markov chain Monte Carlo), or approximate methods like VB (variational Bayes); all of them with their own challenges. However, INLA (Integrated Nested Laplace Approximation) is a deterministic approximate approach, developed by (Rue, Martino y Chopin, 2009) and expanded upon in (Lindgren y Rue, 2015; Rue y col., 2017; Bakka y col., 2018). . It allows for Bayesian inference in a set of structured additive models, termed latent Gaussian models (LGMs). The INLA method enables the calculation of joint posterior distributions, the marginal distributions of each parameter and hyperparameter, as well as combinations of these or the posterior predictive distributions.\nAt the core of INLA is the Laplace approximation applied to the expression of the conditional probability distribution of the latent field. This implies that the latent structure must follow a Gaussian Markov Random Field (GMRF) that can be linked to latent Gaussian models (Lindgren, Rue y Lindström). Although many models can be rewritten in such a way that their structure is similar to an LGM.\nLaplace Approximation The Laplace approximation for a density function $f(x)$ involves transformation using logarithms and carrying out a second-order Taylor series expansion, evaluated at the mode of the function:\n$$ \\begin{array}{r l}\r\\int_X f(x)dx\u0026 =\\int_X\\exp[\\log(f(x))]dx\\\\ \u0026\\approx \\int_X \\exp\\left( \\log(f(x_0)) + (x-x_0)\\left.\\frac{\\partial \\log(f(x))}{\\partial x}\\right\\vert_{x=x_0} + \\frac{(x-x_0)^2}{2}\\left.\\frac{\\partial^2 \\log(f(x))}{\\partial x}^2\\right\\vert_{x=x_0}\\right)dx,\r\\end{array}\r$$\rwhere the function $f(x)$ will be evaluated at the mode, $\\left.f(x)\\right\\vert_{x=x_0}$, such that\n$$x_0=\\{x:\\frac{\\partial f(x)}{\\partial x}=0 \\wedge \\frac{\\partial^2 f(x)}{\\partial x^2} \\neq 0 \\}.$$ That is, the function is evaluated when the first derivative is null, so the first-order term in the Taylor series expansion can be simplified. Also, if we express the second-order term as\n$$\\sigma^2=\\left.\\frac{1}{\\partial^2 \\log(f(x))/\\partial x^2}\\right\\vert_{x=x_0},$$ then we can express the Laplace approximation as the kernel of a Gaussian function:\n$$\\int_Xf(x)dx\\approx f(x_0)\\cdot \\int_X \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)dx.$$ Gaussian Markov Random Field A Gaussian MArkov Random Field (GMRF) is a Gaussian Field (GF) with Markov properties. This means that, given a random vector $\\mathbf{x}\\in \\mathbb{R}^n$ is said GMRF with reference to a graph $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E})$ with mean $\\boldsymbol\\mu$ and precision matrix (symmetric positive difenite) $\\mathbf{Q}\u003e0$ if its density has the following structure\n$$\\pi(\\mathbf{x})=(2\\pi)^{-n/2}|\\mathbf{Q}|^{1/2}\\exp\\left(-\\frac{1}{2}(\\mathbf{x}-\\boldsymbol\\mu)^T\\mathbf{Q}(\\mathbf{x}-\\boldsymbol\\mu)\\right),$$ and\n$$(\\forall i\\neq j) \\left\\lbrace Q_{ij}\\neq 0 \\iff \\{i,j\\}\\in \\mathcal{E}\\right\\rbrace.$$ If the precision matrix $\\mathbf{Q}$ is completely dense then the network $\\mathcal{G}$ is completely connected. This implies that any normal distribution with symmetric positive definite (SPD) covariance matrixes is a GMRF and vice versa.\nIn the case where $\\mathbf{Q}$ is sparse then the properties of GMRFs are really useful and we can make use of them. In particular, a very useful property is the interpretation of the conditional distributions of the elements of a GMRF.\nSuppose $\\mathbf{x}$ is a GMRF with respect to a graph $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E})$, with mean $\\boldsymbol\\mu$ and SPD precision matrix $\\mathbf{Q}\u003e0$, then\n$$\\begin{array}{rcl}\r\\text{E}(x_i|\\mathbf{x}_{-i}) \u0026 = \u0026 \\mu_i - \\frac{1}{Q_{ii}}\\sum_{j:j\\sim i}Q_{ij}(x_j-\\mu_j),\\\\\r\\text{Prec}(x_i|\\mathbf{x}_{-i}) \u0026 = \u0026 Q_{ii},\\\\\r\\text{Corr}(x_i,x_j|\\mathbf{x}_{-ij}) \u0026 = \u0026 -\\frac{Q_{ij}}{\\sqrt{Q_{ii}Q_{jj}}},\\quad i\\neq j.\\\\\r\\end{array}\r$$ The diagonal elements of $\\mathbf{Q}$ are the conditional precisions of $x_i$ given $\\mathbf{x}_{-i}$, while the off-diagonal elements, with a scaling factor, are the conditional correlation between $x_i$ and $x_j$, given $\\mathbf{x}_{-ij}$.\nGaussian Latent Fields The structure on which INLA is based can be summarised in the following hierarchical model:\n$$\\begin{array}{rcl}\r\\mathbf{y}|\\mathbf{\\mathcal{X}},\\boldsymbol\\theta_1 \u0026 \\sim \u0026 \\prod_{i=1}^{n}\\pi(y_i|\\mathcal{X}_i,\\boldsymbol\\theta_1),\\\\\r\\mathbf{\\mathcal{X}}|\\boldsymbol\\theta_2 \u0026 \\sim \u0026 N(\\mathbf{0},\\mathbf{Q}_{\\mathbf{\\mathcal{X}}}^{-1}(\\boldsymbol\\theta_2)),\\\\\r\\boldsymbol\\theta=\\{\\boldsymbol\\theta_1,\\boldsymbol\\theta_2\\} \u0026 \\sim \u0026 \\pi(\\boldsymbol\\theta),\\\\\r\\end{array}\r$$ where $\\mathbf{y}|\\mathbf{\\mathcal{X}},\\boldsymbol\\theta_1$ is the data (or likelihood) level, where $\\mathbf{\\mathcal{X}}$ are the elements of the latent field and $\\boldsymbol\\theta_1$ are the hyperparameters of the likelihood. The elements of the latent field are distributed according to $\\mathbf{\\mathcal{X}}|\\boldsymbol\\theta_2$, following a GMRF with mean ${0}$ and the latent field structure is integrated into the structure of the precision matrix $\\mathbf{Q}_{\\mathbf{\\mathcal{X}}}^{-1}(\\boldsymbol\\theta_2)$, where $\\boldsymbol\\theta_2$ are the hyperparameters of the latent field. Finally, the last level is the one concerning the distribution of the hyperparameters of the model $(\\boldsymbol\\theta)$, comprising both those of the likelihood $(\\boldsymbol\\theta_1)$ and those concerning the latent field $(\\boldsymbol\\theta_2)$.\nThe second level is the latent Gaussian field, which constitutes a latent Gaussian model (LGM). LGMs are a class of models that follow Gaussian processes, be it for time series, spatial models, iid random effects, cluster random effects, etc. Therefore, the Gaussian field that has the above structure can also be formulated according to the linear predictor of the model as\n$$\\begin{array}{c}\r\\boldsymbol\\eta=\\beta_0\\mathbf{1} + \\boldsymbol\\beta\\mathbf{X} + \\sum_{k=1}^K f_k(\\mathbf{u}_k),\r\\end{array}\r$$ where $(\\beta_0, \\boldsymbol\\beta)$ are the parameters associated with the linear effects, while $\\{\\mathbf{f}\\}$ are the unknown functions of the random effects $\\mathbf{U}=\\{\\mathbf{u}\\}, which can have very different structures: iid, random walks, Besag, SPDE (Stochastic Partial Differential Equation), etc.\nBased on the above expression, we can reformulate it in matrix terms $\\boldsymbol\\eta=\\mathbf{A}_j\\mathbf{u}_j$, where the effects $(\\mathbf{u}_j)$ are linked to the predictor of the observations $(\\boldsymbol\\eta)$ through a projection matrix $(\\mathbf{A}_j)$ relative to each effect $(\\mathbf{u}_j)$. This projection matrix integrates the weights associated with the effects, i.e. the values of the explanatory variables for linear effects, smoothing weights or associated weights with SPDEs. That is, we can rewrite it as\n$$\r\\boldsymbol\\eta=\\left(\r\\begin{array}{c}\r\\eta_1\\\\ \\hline\r\\vdots \\\\ \\hline \\eta_K\r\\end{array}\\right)=\\left(\\mathbf{A}_1| \\mathbf{A}_2| \\cdots| \\mathbf{A}_J\\right) \\left(\r\\begin{array}{c}\r\\mathbf{u}_1\\\\ \\hline\r\\mathbf{u}_2 \\\\ \\hline\r\\vdots \\\\ \\hline \\mathbf{u}_J\r\\end{array}\\right),\r$$ where each effect $\\mathbf{u}_j:j\\in (1,...,J)$ is related to its corresponding projection matrix $\\mathbf{A}_j$, linking the effects with the linear predictor $\\boldsymbol\\eta=(\\eta_1,...,\\eta_K)$.\nKey Articles Bakka, H., Rue, H., Fuglstad, G.-A., Riebler, A. I., Bolin, D., Illian, J., Krainski, E., Simpson, D. P., \u0026 Lindgren, F. K. (2018). Spatial modelling with INLA: A review. In Wires (Vol. xx, Issue Feb). https://doi.org/10.1002/wics.1443\rLindgren, F., Rue, H., \u0026 Lindström, J. (2011). An explicit link between gaussian fields and gaussian markov random fields: The stochastic partial differential equation approach. Journal of the Royal Statistical Society. Series B: Statistical Methodology, 73(4). https://doi.org/10.1111/j.1467-9868.2011.00777.x\rLindgren, F., \u0026 Rue, H. (2015). Bayesian spatial modelling with R-INLA. Journal of Statistical Software, 63(19). https://doi.org/10.18637/jss.v063.i19\rRue, H., Martino, S., \u0026 Chopin, N. (2009). Approximate Bayesian inference for latent Gaussian models by using integrated nested Laplace approximations. Journal of the Royal Statistical Society. Series B: Statistical Methodology, 71(2). https://doi.org/10.1111/j.1467-9868.2008.00700.x\rRue, H., Riebler, A., Sørbye, S., Illian, J., Simpson, D. \u0026 Lindgren, F. (2017). Bayesian Computing with INLA: A Review. Annual Review of Statistics and Its Application, 4:1, 395-421. https://doi.org/10.1146/annurev-statistics-060116-054045\rBooks Blangiardo, M., \u0026 Cameletti, M. (2015). Spatial and Spatio-temporal Bayesian Models with R - INLA. In Spatial and Spatio-temporal Bayesian Models with R - INLA. Wiley. https://doi.org/10.1002/9781118950203\rGómez-Rubio, V. (2020). Bayesian Inference with INLA. In Bayesian Inference with INLA. Chapman \u0026 Hall/CRC Press. https://doi.org/10.1201/9781315175584\rMoraga, P. (2019). Geospatial Health Data. Chapman and Hall/CRC. https://doi.org/10.1201/9780429341823\rKrainski, E., Gómez-Rubio, V., Bakka, H., Lenzi, A., Castro-Camilo, D., Simpson, D., Lindgren, F., \u0026 Rue, H. (2018). Advanced Spatial Modeling with Stochastic Partial Differential Equations Using R and INLA. In Advanced Spatial Modeling with Stochastic Partial Differential Equations Using R and INLA. https://doi.org/10.1201/9780429031892\rRue, H., \u0026 Held, L. (2005). Gaussian Markov Random Fields. Chapman and Hall/CRC. https://doi.org/10.1201/9780203492024\rXiaofeng Wang, Ryan Yue, \u0026 Faraway, J. J. (2018). Bayesian Regression Modeling with INLA. Chapman \u0026 Hall. ",
    "description": "",
    "tags": null,
    "title": "INLA",
    "uri": "/inla/index.html"
  },
  {
    "content": "",
    "description": "Simulated Dirichlet data fitted with iid (unstructured diagonal) random effects model.",
    "tags": null,
    "title": "Example with iid (unstructured diagonal) effects",
    "uri": "/inla/extensions/dirinla/unstructure_random_effects/index.html"
  },
  {
    "content": "inlabru methodology ",
    "description": "",
    "tags": null,
    "title": "inlabru",
    "uri": "/inlabru/index.html"
  },
  {
    "content": "",
    "description": "A short introduction to inla stacks and their uses.",
    "tags": null,
    "title": "Stacks",
    "uri": "/inla/basicoperationalinfo/stacks/index.html"
  },
  {
    "content": "",
    "description": "Simulated Dirichlet data fitted with spatial structured random effects model.",
    "tags": null,
    "title": "Example with spatial structured random effects",
    "uri": "/inla/extensions/dirinla/spde2_random_effects/index.html"
  },
  {
    "content": "",
    "description": "Brief introduction to the construction of meshes: applications and  operational basis.",
    "tags": null,
    "title": "Mesh Construction",
    "uri": "/inla/basicoperationalinfo/meshes/index.html"
  },
  {
    "content": "",
    "description": "A short introduction to INLA advanced features and their uses.",
    "tags": null,
    "title": "Advanced Features",
    "uri": "/inla/basicoperationalinfo/advanced_features/index.html"
  },
  {
    "content": " Version infromation In this we expose a list with all the versions of the programms, operative system and the libraries used in this section code, which almost is extracted from sessionInfo().\nSO (version): Windows 11 Home (22H2). R: 4.2.2 (2022-10-31 ucrt). RStudio: 2022.07.2 (Build 576). Libraries: INLA: INLA_22.05.07 inlabru: inlabru_2.5.3 sp: sp_1.5-0 sf: sf_1.0-8 ggplot2: ggplot2_3.3.6 viridis: viridis_0.6.2 There may be cases when you need to work with inla elements as if they were spatial objects (usually sp or sf), this will be particularly appropriate when working with meshes or mesh edges. Whatever the reasons for passing the mesh or mesh edges to spatial objects, there is no built-in function available in library(INLA), so we will proceed with its definition.\nMesh to spatial object Suppose we start from a set of points given by the XY data frame, on which we apply the function inla.nonconvex.hull to obtain the boundary of our mesh, resulting from the morphological operations of dilation and closure incorporated for the formation of the outer edge.\nGet XY data library(INLA) library(inlabru) XY \u003c- readRDS(file=\"XY.rds\") INLAnonconvex \u003c- inla.nonconvex.hull(XY, convex=1000, resolution=400) INLAnonconvexMesh \u003c- inla.mesh.2d(boundary=INLAnonconvex, max.edge=5000) If we plot the mesh ggplot() + inlabru::gg(INLAnonconvexMesh) + theme_void() we obtain the following figure:\nFig. 1: INLA mesh with non convex boundary Once the mesh is available, to transform the tessellation into a spatial object (sp) we use the information integrated in the mesh object (mesh). Specifically in the rows of the mesh$graph$tv matrix, which store the vertex positions for each i-th triangle. In this way, we simply inscribe the vertex indices for each triangle in the coordinate matrix of the vertices themselves, forming a polygon with each one and finally grouping the result in a SpatialPolygons object, or in a This is synthesized in the following function:\nsp sf SpatialPolygonDelaunay \u003c- function(mesh){ return(SpatialPolygons(sapply(1:nrow(mesh$graph$tv), function(i){ list(Polygons(list(Polygon(mesh$loc[mesh$graph$tv[i,],1:2])),i )) }) )) } SpatialPolygonDelaunay \u003c- function(mesh){ return(st_polygon(sapply(1:nrow(mesh$graph$tv), function(i){ list(mesh$loc[c(mesh$graph$tv[i,], mesh$graph$tv[i,1]),1:2]) }) )) } Such that the object transformed would be given by:\nSpatialPolygonMesh \u003c- SpatialPolygonDelaunay(mesh=INLAnonconvexMesh) Boundary to spatial object In this case we intend to transform the edges of the mesh to SpatialPolygons, in such a way that we can account for the gaps present in the mesh. So, the first thing to do is to convert the edges into simply connected polygons (without gaps).\nTo correctly conform a polygon, the order of succession of the points on the perimeter of the polygon must be indicated, such that the first point is also the last point to close the polygon. This can be easily done because the mesh stores the locations of the vertices that make up the edges as pairs of points in the rows of the mesh$segm$bnd$idx matrix. That is, if the points refer to the same polygon we will have the connection established from the pairs of indexes going through the rows of this matrix, such that it will come to repeat in the first column the position of the initial point to close the polygon.\nTherefore, knowing that the sequence of indices for each closed curve implies that the last pair ends at the first point (first pair of indices), we will have that the element of the first column of the next row will be different from the element of the second column of the reference row: mesh$segm$bnd$idx[i+1,1]!=mesh$segm$bnd$idx[i,1]. So, through this condition, we can set the indices of the polygon boundaries that we want to reconstruct as spatial objects (sp or sf).\nsp sf SpatialPolygonsBoundary \u003c- function(mesh){ BoundaryIndx \u003c- sapply(1:(nrow(mesh$segm$bnd$idx)-1), function(i){ return(mesh$segm$bnd$idx[i+1,1]==mesh$segm$bnd$idx[i,2]) }) BoundaryIndxLims \u003c- which(!BoundaryIndx) BoundaryIndxLims \u003c- c(0, BoundaryIndxLims, nrow(mesh$segm$bnd$idx)) SpatialPolygonsBoundary \u003c- SpatialPolygons(sapply(2:(length(BoundaryIndxLims)), function(i){ VertixBoundaryIndex \u003c- matrix(c(mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1):BoundaryIndxLims[i],1], mesh$segm$bnd$idx[BoundaryIndxLims[i],2]), ncol=1, byrow=TRUE) return(list(Polygons(list(Polygon(mesh$loc[VertixBoundaryIndex,1:2])),i))) })) return(SpatialPolygonsBoundary) } SpatialPolygonsBoundary \u003c- function(mesh){ BoundaryIndx \u003c- sapply(1:(nrow(mesh$segm$bnd$idx)-1), function(i){ return(mesh$segm$bnd$idx[i+1,1]==mesh$segm$bnd$idx[i,2]) }) BoundaryIndxLims \u003c- which(!BoundaryIndx) BoundaryIndxLims \u003c- c(0, BoundaryIndxLims, nrow(mesh$segm$bnd$idx)) SpatialPolygonsBoundary \u003c- st_polygon(sapply(2:(length(BoundaryIndxLims)), function(i){ VertixBoundaryIndex \u003c- c(mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1),1], mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1):BoundaryIndxLims[i],2]) return(list(cbind(mesh$loc[VertixBoundaryIndex,1:2]))) })) return(SpatialPolygonsBoundary) } Then, once all the polygons have been formed from the edges given by the INLA function, these polygons must be transformed to account for the gaps they may contain and are present. To do this we can either perform a mathematical approach to the properties of the problem, using set theory for ordered sets, or we can approach it operationally to solve it.\nOperational reasoning. To do this according to an operational approach we must consider that we have formed a polygon for each closed curve, for each edge or boundary, so that these curves may contain within them other surfaces given by other curves. In addition, some of these polygons may be associated with the inner edge of the polygons, which would refer to the boundary of the inner hole of the polygon, so that we can have to classify the polygons obtained in two classes or types: full polygons and hollow polygons, depending on whether they refer to the border of a “full” area or a “hollow” area. In addition, it must be taken into account that a filled polygon will contain in the next level of maximum internal intersection, in case of containing in its interior other polygons, a hollow polygon. While for the case of hollow polygons this condition assumes the counterpart; namely, that the next level of maximum internal intersection will be a filled polygon. Such that the level of maximal internal intersectionality with respect to a given polygon we shall understand as the polygon of largest area that is completely contained in the reference polygon. But we can extend this definition according to different sets of mutually independent polygons, where the maximum internal intersectionality for the reference polygon is no longer a single polygon, but the largest polygon of each of these mutually disjoint sets.\nOn the other hand, if a polygon, bounded by one of these given curves, has a non-zero intersection with others, then this intersection will totally reproduce one of the two polygons.\nSubsequently, if analogously to an adjacency or neighborhood matrix, we elaborate an intersectionality matrix, determined according to the intersection operation of a given polygon on the rest of polygons. Such that the matrix will contain the relations between a given polygon with the whole set of polygons according to the intersection operation, operation that will be worth 1 if there is intersection and 0 if there is not. Therefore, for each row or column we will obtain the intersection of a polygon with the rest, where the diagonal of the matrix would manifest the intersection of a polygon with itself, so the main diagonal will be a vector of ones.\nFrom the intersectionality matrix we can conclude that the rows or columns whose sum is unitary (only the element of the main diagonal will be different from 0 for that row or column), will belong to a polygon that will not contain any other polygon, whether it is hollow or full. Therefore, we could extract these polygons as correctly defined polygons that do not require any transformation.\nFinally, in case a given row sums to more than one it will imply that it contains at least one hole. So to form the polygons with the holes we can approach the procedure in the following way:\nFirst, for each row we can search for the smallest polygon (area) in the whole set of intersecting polygons, from which a completely ordered set will be constructed according to the intersections of the polygon. Secondly, the set of polygons can be recomposed as the rearrangement into the smallest number of totally ordered sets. Such that from these totally ordered sets we will know that the largest of the sets refers to a filled polygon, the next to a hollow one, … and so on. To thirdly, to conform by means of operations of difference and union the different polygons that account for the existing hollows. Mathematical reasoning. From a mathematical approach we can use set theory to evaluate the set of operations to be performed to solve the question. To do this, the first thing we must do is to establish the conditions of the problem:\nWe have a set of $n$ polygons $p_i$, such that the universal set of reference will be $\\displaystyle P=\\{p_1, …, p_n\\}$. These polygons ar esubsets of the two dimensional Euclidian space, $p_i\\subset \\mathbb{R}^2$. There are two kinds of polygons: (i) filled polygons $P_{F}=\\{p_{fi}\\}$ and (ii) hollow polygons $P_H=\\{p_{hi}\\}$, by jointly reproducing the universal set of polygons $P=P_F\\cup P_H$. There is a function $f$ that stablish the relation between a polygon $p_i$ with its area $a_i$, such that $f:P\\longmapsto A$ implies $f(p_i)=a_i$. However, this function is only surjective if we assume that there can be two or more polygons with the same area, while it would be surjective and injective if for each polygon it has a different area. If the intersection of two polygons is non-zero, then the intersection results in the polygon of smaller area. That is, $p_i\\cap p_j=\\{\\emptyset\\veebar p_j\\}|f(p_i)\u003ef(p_j)$. In addition, we have as a condition that there is no polygon intersecting with another that has the same area, $(\\nexists p_i)(p_i,p_j\\in P): f(p_i)=f(p_j)\\iff \\{p_i\\cap p_j\\neq \\emptyset \\wedge i\\neq j\\}$. For the set of all non-zero intersections of polygons $(p_i, p_j)$, we will have that the set with the largest area is a filled polygon $f(p_i)\u003ef(p_j):p_i\\in P_F$. Finally, as a weak condition between the non-zero intersection of two filled polygons, we have that there exists, at least, a hollow polygon with greater area than that of the filled polygon of smaller area and that also intersects with them. In other words, if $p_j\\subset p_i:p_i,p_j\\in P_F\\Rightarrow (\\exists p_k) p_k\\in P_H: p_j\\subset p_k\\subset p_i$. While the strong condition will be, that if we have two polygons such that one is a subset of another with no filled polygon that can be incorporated as a middle element between the two by the subset operation, then there exists one and only one hollow polygon that lies between the two: $$(\\forall p_i,p_j\\in P_F) p_j\\subset p_i:\\nexists p_k\\in P_F, p_j \\subset p_k \\wedge p_k\\subset p_i \\iff \\exists! p_z\\in P_H: p_j\\subset p_z \\wedge p_z\\subset p_i.$$\rGiven these conditions it is obvious that we can reorder the set $P$ of all the polygons, in such a way that we have the least number of completely ordered sets of higher cardinality whose union reproduces the set { $P$} of reference. That is to say, we have to conform all those completely ordered sets $(P_i,\\subset)$, which implies that $(\\forall p_i) p_i\\in P_i (\\exists p_j)p_j\\in P_i\\rightarrow p_j\\subset p_i \\vee p_i\\subset p_j$. Therefore, we shall construct these completely ordered sets $P_i=\\{p_{i1}\\subset p_{2i}\\subset … \\subset p_{ni}\\}$, of which we know from conditions (5) and (6) that for any of these sets $P_i$, we will have that the filled polygons will be:\n$$ \\{ p_{ki},p_{(k-2)i},...,\\}\\in P_F \\Rightarrow p_{(k-2m)i}\\in P_F: m\\in M\\subset\\mathbb{N},$$\rwhile the hollow polygons would be:\r$$ \\{ p_{(k-1)i},p_{(k-3)i},...,\\}\\in P_H \\Rightarrow p_{(k-1-2m)i}\\in P_H: m'\\in M'\\subset\\mathbb{N}.$$\rThe code to perform the pertinent transformations and obtain the polygons with the corresponding holes is as follows:\nsp CompleteOrderedSetsFromSpatialPolygonsClass \u003c- function(SPDINLAnonconvexBoundary){ SPDINLABoundaryList \u003c- list(Polygons=list(), DFIDArea=data.frame(matrix(ncol=2,nrow=0, dimnames=list(NULL, c(\"ID\", \"Area\")))) ) for(i in 1:length(SPDINLAnonconvexBoundary)){ SPDINLABoundaryList$Polygons[[i]] \u003c- SPDINLAnonconvexBoundary[i] SPDINLABoundaryList$DFIDArea[i,] \u003c- c(i, SPDINLAnonconvexBoundary[i]@polygons[[1]]@area) } IndexIDV \u003c- SPDINLABoundaryList$DFIDArea$ID ConnectivityMatrix \u003c- matrix(ncol=length(SPDINLAnonconvexBoundary), nrow=length(SPDINLAnonconvexBoundary)) for(i in 1:length(SPDINLAnonconvexBoundary)){ for(j in i:length(SPDINLAnonconvexBoundary)){ ConnectivityMatrix[i,j] \u003c- ConnectivityMatrix[j,i] \u003c- as.numeric(gIntersects(SPDINLAnonconvexBoundary[i], SPDINLAnonconvexBoundary[j])) } } IndexIsolatedPolygonFill \u003c- which(apply(ConnectivityMatrix, FUN=sum, MARGIN=1)==1) IndexIDV \u003c- if(length(IndexIsolatedPolygonFill)==0){IndexIDV} else{IndexIDV[-which(apply(ConnectivityMatrix, FUN=sum, MARGIN=1)==1)]} CompleteOrderedSets \u003c- list(CompleteOrderedSets=list(), DFCompleteOrderedSets=list(), CompleteOrderedIsolatedSets=list(), DFCompleteOrderedIsolatedSets=list()) if(length(IndexIsolatedPolygonFill)!=0){ for(i in 1:length(IndexIsolatedPolygonFill)){ CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]] \u003c- SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]] CompleteOrderedSets$DFCompleteOrderedIsolatedSets[[i]] \u003c- data.frame(ID=SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]]@polygons[[1]]@ID, Area=SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]]@polygons[[1]]@area, HOLE=FALSE) } } if(length(IndexIsolatedPolygonFill)!=length(IndexIDV)){ n_step \u003c- 1 while(length(IndexIDV)!=0){ IDminArea \u003c- SPDINLABoundaryList$DFIDArea[IndexIDV,\"ID\"][which.min(SPDINLABoundaryList$DFIDArea[IndexIDV,\"Area\"])] IndxCOS \u003c- which(as.logical(ConnectivityMatrix[IDminArea,])) DFIDAreaV \u003c- SPDINLABoundaryList$DFIDArea[IndxCOS,] CompleteOrderedSets$CompleteOrderedSets[[n_step]] \u003c- SpatialPolygons(sapply(DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"ID\"], function(i){ list(SPDINLABoundaryList$Polygons[[i]]@polygons[[1]]) }) ) CompleteOrderedSets$DFCompleteOrderedSets[[n_step]] \u003c- data.frame(ID=DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"ID\"], Area=DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"Area\"], HOLE=floor(1:length(IndxCOS)/2)==1:length(IndxCOS)/2 ) IndexIDV \u003c- setdiff(IndexIDV,IndxCOS) n_step \u003c- n_step+1 } SpatialPolygonsNames \u003c- c() for(i in 1:length(CompleteOrderedSets$CompleteOrderedSets)){ if(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2!=floor(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2)){ SpatialPolygonsNames \u003c- c(SpatialPolygonsNames, paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[length(CompleteOrderedSets$CompleteOrderedSets[[i]])])) assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[length(CompleteOrderedSets$CompleteOrderedSets[[i]])]), value=SpatialPolygons(list( CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[length(CompleteOrderedSets$CompleteOrderedSets[[i]])]] ))) } for(j in 1:floor(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2)){ indx \u003c- 1:2+2*(j-1) if(exists(paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]))){ assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]), value=gDifference(eval(parse(text=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]))), SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[2]]])), id=paste0(CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]) ) ) } else{ SpatialPolygonsNames \u003c- c(SpatialPolygonsNames, paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]])) assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]), value=gDifference(SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[1]]])), SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[2]]])), id=paste0(CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]) ) ) }} if(length(IndexIsolatedPolygonFill)!=0){ SpatialPolygonRefined \u003c- SpatialPolygons(c(lapply(1:length(SpatialPolygonsNames), function(i){ return(eval(parse(text=paste0(SpatialPolygonsNames[i], \"@polygons[[1]]\")))) }), lapply(1:length(CompleteOrderedSets$CompleteOrderedIsolatedSets), function(i){ return(CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]]@polygons[[1]]) }))) } else{ SpatialPolygonRefined \u003c- SpatialPolygons(lapply(1:length(SpatialPolygonsNames), function(i){ return(eval(parse(text=paste0(SpatialPolygonsNames[i], \"@polygons[[1]]\")))) })) } } } else{ SpatialPolygonRefined \u003c- SpatialPolygons(lapply(1:length(CompleteOrderedSets$CompleteOrderedIsolatedSets), function(i){ return(CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]]@polygons[[1]]) })) } SpatialPolygonRefined@proj4string \u003c- CRS(\"+proj=utm\") CompleteOrderedSetsAndPolygons \u003c- list(CompleteOrderedSets=CompleteOrderedSets, SpatialPolygonRefined=SpatialPolygonRefined) return(CompleteOrderedSetsAndPolygons) } Thanks to this function we have all the polygons according to the closed curves that determine them. This allows us to perform operations on them, so that we are taking into account the existing gaps.\nTherefore, following the example, we would have to apply the first function SpatialPolygonsBoundary on the result of the mesh INLAnonconvexMesh, and then apply the function just defined.\nSPDINLAnonconvexBoundary \u003c- SpatialPolygonsBoundary(mesh = INLAnonconvexMesh) PolygonsRefined \u003c- CompleteOrderedSetsFromSpatialPolygonsClass(SPDINLAnonconvexBoundary = SPDINLAnonconvexBoundary) In order to visualize that we now have all the polygons available independent of each other, we can plot them in different colors:\ncol \u003c- viridis::turbo(length(PolygonsRefined$SpatialPolygonRefined)) ggplotPolygons \u003c- ggplot() for(i in 1:length(PolygonsRefined$SpatialPolygonRefined)){ ggplotPolygons \u003c- ggplotPolygons + geom_sf(data=st_as_sf(PolygonsRefined$SpatialPolygonRefined[i]), fill=col[i], alpha=0.5) } So, if we represent the polygons as ggplotPolygons + theme_void() we will obtain the following figure:\nFig. 2: Refined polygons Example with nested polygons. We will present a small example to show that the function is able to extract an arbitrary order of polygons, even if they are stacked. That is, in principle, the function applies to any case in general that meets two conditions, (i) the total intersection and (ii) the polygon-full / polygon-hollow ordering in successive levels of maximum internal intersection.\nThe first thing we will do to check that such a function is able to operate with stacked polygons is to create the polygons:\nrho1 \u003c- rnorm(120,1,0.01); theta1 \u003c- runif(120,0,2*pi) rho2 \u003c- rnorm(120,6,0.01); theta2 \u003c- runif(120,0,2*pi) rho3 \u003c- rnorm(220,12,0.01); theta3 \u003c- runif(220,0,2*pi) XYPoint \u003c- as.matrix(rbind( cbind(rho1*cos(theta1), rho1*sin(theta1)), cbind(rho2*cos(theta2), rho2*sin(theta2)), cbind(rho3*cos(theta3), rho3*sin(theta3)) )) Boundary \u003c- inla.nonconvex.hull(points=XYPoint, convex=1, resolution=c(100,100)) INLAnonconvexMesh \u003c- inla.mesh.2d(boundary=Boundary, max.edge=1) SPDINLAnonconvexBoundary \u003c- SpatialPolygonsBoundary(mesh=INLAnonconvexMesh) Fig. 3: Nested polygons Fig. 4: Mesh of nested polygons Then we apply the function to extract the polygons with the holes and plot the result:\nPolygonsRefined \u003c- CompleteOrderedSetsFromSpatialPolygonsClass(SPDINLAnonconvexBoundary=SPDINLAnonconvexBoundary) col \u003c- viridis::turbo(length(PolygonsRefined$SpatialPolygonRefined)) ggplotPolygons \u003c- ggplot() for(i in 1:length(PolygonsRefined$SpatialPolygonRefined)){ ggplotPolygons \u003c- ggplotPolygons + geom_sf(data=st_as_sf(PolygonsRefined$SpatialPolygonRefined[i]), fill=col[i], alpha=0.5) } Fig. 5: Nested polygons fixing holes ",
    "description": "Here we define some functions related to the transformations of inla.mesh objects to sp and sf.",
    "tags": null,
    "title": "Transformation to sp/sf",
    "uri": "/inla/variousfunctions/inlatosp/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "Esta sección está dedicada específicamente al paquete dirinla que está construido sobre el enfoque implementado en R-INLA. Para que los ejemplos resulten comprensibles dedicaremos esta parte introductoria para sintetizar los fundamentos matemáticos y operativos de dirinla. Esto es, realizaremos una síntesis del artículo Martínez-Minaya et al. (2023) en el que se presenta el paquete y también se evaluarán algunas funciones que integran el paquete, modificándolas allí donde se considere pertinente.\nExamples Example with fixed effectsSimulated Dirichlet data fitted with a fixed effects model.\nExample with iid (unstructured diagonal) effectsSimulated Dirichlet data fitted with iid (unstructured diagonal) random effects model.\nExample with spatial structured random effectsSimulated Dirichlet data fitted with spatial structured random effects model.\nINLA for Fitting Dirichlet Regression Models (Summary) References Joaquín Martínez-Minaya, Finn Lindgren, Antonio López-Quílez, Daniel Simpson \u0026 David Conesa (2023) The Integrated Nested Laplace Approximation for Fitting Dirichlet Regression Models, Journal of Computational and Graphical Statistics, 32:3, 805-823, DOI: https://doi.org/10.1080/10618600.2022.2144330 Depaoli, S., Clifton, J. P., \u0026 Cobb, P. R. (2016). Just Another Gibbs Sampler (JAGS): Flexible Software for MCMC Implementation. Journal of Educational and Behavioral Statistics, 41(6), 628–649. http://www.jstor.org/stable/26447820 ",
    "description": "Examples using the dirinla R package for Compositional Data (CoDa).",
    "tags": null,
    "title": "dirinla",
    "uri": "/inla/extensions/dirinla/index.html"
  },
  {
    "content": "In this section we will show\n",
    "description": "A simple geostatical model in INLA.",
    "tags": null,
    "title": "Geostatistical Model",
    "uri": "/inla/spatialmodels/geostatisticalmodel/index.html"
  },
  {
    "content": "In this section we will show\ndirinlaExamples using the dirinla R package for Compositional Data (CoDa).\n",
    "description": "INLA's extensions.",
    "tags": null,
    "title": "INLA's extensions",
    "uri": "/inla/extensions/index.html"
  },
  {
    "content": "In this section we will show\n",
    "description": "A joint model for preferentially sampled data.",
    "tags": null,
    "title": "Preferential Model",
    "uri": "/inla/spatialmodels/jointmodel_preferential/index.html"
  },
  {
    "content": "In this section we will show\nGeostatistical ModelA simple geostatical model in INLA.\nPreferential ModelA joint model for preferentially sampled data.\nSVC ModelSpatially Varying Coefficient Model.\n",
    "description": "Spatial Model section (SPDE-FEM).",
    "tags": null,
    "title": "Spatial Models (SPDE-FEM)",
    "uri": "/inla/spatialmodels/index.html"
  },
  {
    "content": "In this section we will show\n",
    "description": "Spatially Varying Coefficient Model.",
    "tags": null,
    "title": "SVC Model",
    "uri": "/inla/spatialmodels/spatialvaryingcoefficientmodel/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  },
  {
    "content": "Here we will present different functions that have been developed for implementation in automated processes or that may be of interest.\nTransformation to sp/sfHere we define some functions related to the transformations of inla.mesh objects to sp and sf.\n",
    "description": "List the child pages of a page",
    "tags": null,
    "title": "Various Functions",
    "uri": "/inla/variousfunctions/index.html"
  }
]
