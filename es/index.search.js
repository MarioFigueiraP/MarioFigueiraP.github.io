var relearn_search_index = [
  {
    "content": "",
    "description": "Datos Dirichlet simulados ajustados con un modelo de efectos fijos.",
    "tags": null,
    "title": "Ejemplos con efectos fijos",
    "uri": "/es/inla/extensions/dirinla/linear_effects/index.html"
  },
  {
    "content": "Introducción En esta GitHub Page se expondrán cuestiones relativas a estadística bayesiana y modelización con un doble propósito. Primeramente, como un modo de organizar el material que voy desarrollando a lo largo de distintos proyectos y del doctorado. En segundo lugar, como posible apoyo para aquellos interesados en este campo, por si este material resultara de algún interés y ayuda.\nLos principales temas que se podrán encontrar aquí están relacionados con:\nINLA (Integrated Nested Laplace Approximation) e inlabru MCMC (Markov Chain Monte Carlo) Modelización jerárquica Modelización espacial Modelización temporal Modelización espacio temporal Aplicaciones Shiny Con el fin de ceñirnos a una metodología en el que la replicabilidad y reproducción de los resultados obtenidos es absolutamente perentoria, se indica al inicio de cada sección el sistema operativo, la versión del lenguaje de programación, del entorno de programación para dicho lenguaje, junto con el código y datos empleados. No obstante, tan sólo esto muchas veces podrá ser insuficiente, por lo que dependiendo del código implementado pueda requerirse el indicar la versión de paquetes, librerías o bibliotecas usadas en cada caso.\nSobre mí Resumen Una imagen Mi nombre es Mario Figueira y soy un estudiante de doctorado en Estadística y Optimización por la Universidad de Valencia, concretamente mi línea de investigación se centra en modelización Bayesiana espacio-temporal. ",
    "description": "",
    "tags": null,
    "title": "Inicio",
    "uri": "/es/index.html"
  },
  {
    "content": "Metodología INLA Existen distintas metodologías para la realización computacional de inferencia bayesiana, métodos de simulación como MCMC (Markov chain Monte Carlo) o métodos aproximativos como VB (variational Bayes); todas ellas con sus dificultades propias. No obstante, INLA (Integrated Nested Laplace Approximation) es un enfoque determinista aproximado, desarrollado por (Rue, Martino y Chopin, 2009) y ampliado en (Lindgren y Rue, 2015; Rue y col., 2017; Bakka y col., 2018), que permite realizar la inferencia Bayesiana en un conjunto de modelos aditivos estructurados, denominados modelos Gaussianos latentes (LGMs). El método de INLA permite el cálculo de las dsitribuciones posteriores conjuntas, las distribuciones marginales de cada parámetro e hiperparámetro, así como combinaciones de estos o las distribuciones predictivas posteriores.\nEl núcleo de INLA es la aproximación de Laplace aplicada a la expresión de la distribución de probabilidad condicional del campo latente. Esto implica que la estructura latente debe ser la de un campo Gaussiano Markoviano aleatorio (GMRF) que puede ligarse a modelos Gaussianos latentes (Lindgren, Rue y Lindström). Aunque muchos modelos pueden ser re-escritos de tal modo que su estructura sea sigmilar a la de un LGM.\nAproximación de Laplace La aproximación de Laplace para una función de densidad $f(x)$ supone la transformación mediante logaritmos y la realización de un desarrollo en serie de Taylor de segundo orden, evaluado en la moda de la función:\n$$ \\begin{array}{r l}\r\\int_X f(x)dx\u0026 =\\int_X\\exp[\\log(f(x))]dx\\\\ \u0026\\approx \\int_X \\exp\\left( \\log(f(x_0)) + (x-x_0)\\left.\\frac{\\partial \\log(f(x))}{\\partial x}\\right\\vert_{x=x_0} + \\frac{(x-x_0)^2}{2}\\left.\\frac{\\partial^2 \\log(f(x))}{\\partial x}^2\\right\\vert_{x=x_0}\\right)dx,\r\\end{array}\r$$\rdonde la función $f(x)$ será evaluada en la moda, $\\left.f(x)\\right\\vert_{x=x_0}$, tal que\n$$x_0=\\{x:\\frac{\\partial f(x)}{\\partial x}=0 \\wedge \\frac{\\partial^2 f(x)}{\\partial x^2} \\neq 0 \\}.$$ Esto es, la función queda evaluada cuando la primera derivada es nula, por lo que el término del desarrollo en serie de Taylor de primer orden puede ser simplificado. Además, si expresamos el término de segundo orden como\n$$\\sigma^2=\\left.\\frac{1}{\\partial^2 \\log(f(x))/\\partial x^2}\\right\\vert_{x=x_0},$$ entonces podemos expresar la aproximación de Laplace como el kernel de una función Gaussiana:\n$$\\int_Xf(x)dx\\approx f(x_0)\\cdot \\int_X \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)dx.$$ Campo Gaussiano Markoviano Aleatorio Un campo Gaussiano Markoviano aleatorio (GMRF) es un campo Gaussiano (GF) con propiedades de Markov. Es decir, dado un vector aleatorio $\\mathbf{x}\\in \\mathbb{R}^n$ se dice GMRF con referencia a un grafo $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E})$ con media $\\boldsymbol\\mu$ y matriz de precisión (simétrica definida positiva) $\\mathbf{Q}\u003e0$ si su densidad tiene la siguiente estructura\n$$\\pi(\\mathbf{x})=(2\\pi)^{-n/2}|\\mathbf{Q}|^{1/2}\\exp\\left(-\\frac{1}{2}(\\mathbf{x}-\\boldsymbol\\mu)^T\\mathbf{Q}(\\mathbf{x}-\\boldsymbol\\mu)\\right),$$ y\n$$(\\forall i\\neq j) \\left\\lbrace Q_{ij}\\neq 0 \\iff \\{i,j\\}\\in \\mathcal{E}\\right\\rbrace.$$ Si la matriz de precisión $\\mathbf{Q}$ es completamente densa entonces el grafo $\\mathcal{G}$ está completamente conectado. Esto implica que cualquier distribución normal con matriz de covarianzas simétrica definida positiva (SPD) es un GMRF y vice versa.\nEn el caso en el que $\\mathbf{Q}$ es dispersa entonces las propiedades de los GMRFs son realmente útiles y podremos hacer uso de ellas. En particular, una propiedades de gran utilidad es la intepretación de las distribuciones condicionales de los elementos de un GMRF.\nSupongamos que $\\mathbf{x}$ es un GMRF con respecto a un grafo $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E})$, con media $\\boldsymbol\\mu$ y matriz de precisión (simétrica definida positiva) $\\mathbf{Q}\u003e0$, entonces\n$$\\begin{array}{rcl}\r\\text{E}(x_i|\\mathbf{x}_{-i}) \u0026 = \u0026 \\mu_i - \\frac{1}{Q_{ii}}\\sum_{j:j\\sim i}Q_{ij}(x_j-\\mu_j),\\\\\r\\text{Prec}(x_i|\\mathbf{x}_{-i}) \u0026 = \u0026 Q_{ii},\\\\\r\\text{Corr}(x_i,x_j|\\mathbf{x}_{-ij}) \u0026 = \u0026 -\\frac{Q_{ij}}{\\sqrt{Q_{ii}Q_{jj}}},\\quad i\\neq j.\\\\\r\\end{array}\r$$ Los elementos diagonales de $\\mathbf{Q}$ son las precisiones condicionales de $x_i$ dado $\\mathbf{x}_{-i}$, mientras que los elementos fuera de la diagonal, con un escalado, son la correlación condicional entre $x_i$ y $x_j$, dados $\\mathbf{x}_{-ij}$.\nCampos Gaussianos latentes La estructura en la que se basa INLA puede sintetizarse en el siguiente modelo jerárquico:\n$$\\begin{array}{rcl}\r\\mathbf{y}|\\mathbf{\\mathcal{X}},\\boldsymbol\\theta_1 \u0026 \\sim \u0026 \\prod_{i=1}^{n}\\pi(y_i|\\mathcal{X}_i,\\boldsymbol\\theta_1),\\\\\r\\mathbf{\\mathcal{X}}|\\boldsymbol\\theta_2 \u0026 \\sim \u0026 N(\\mathbf{0},\\mathbf{Q}_{\\mathbf{\\mathcal{X}}}^{-1}(\\boldsymbol\\theta_2)),\\\\\r\\boldsymbol\\theta=\\{\\boldsymbol\\theta_1,\\boldsymbol\\theta_2\\} \u0026 \\sim \u0026 \\pi(\\boldsymbol\\theta),\\\\\r\\end{array}\r$$ donde $\\mathbf{y}|\\mathbf{\\mathcal{X}},\\boldsymbol\\theta_1$ es la parte relativa a los datos (o verosimilitud), siendo $\\mathbf{\\mathcal{X}}$ los elementos del campo latente y $\\boldsymbol\\theta_1$ los hiperparámetros de la verosimilitud. Los elementos del campo latente se distribuyen según $\\mathbf{\\mathcal{X}}|\\boldsymbol\\theta_2$, siguiendo un GMRF de media $\\mathbf{0}$ y la estructura del campo latente queda integrada en la estructura de la matriz de precisión $\\mathbf{Q}_{\\mathbf{\\mathcal{X}}}^{-1}(\\boldsymbol\\theta_2)$, donde $\\boldsymbol\\theta_2$ son los hiperparámetros del campo latente. Finalmente, el último nivel es el relativo a la distribución de los hiperparámetros del modelo $(\\boldsymbol\\theta)$, comprendiendo tanto a los de la verosimilitud $(\\boldsymbol\\theta_1)$ como los relativos al campo latente $(\\boldsymbol\\theta_2)$.\nEl segundo nivel es el campo Gaussiano latente, que constituye un modelo Gaussiano latente (LGM). Los LGMs son una clase de modelos que siguen procesos Gaussianos, sea tanto para series temporales, modelos espaciales, efectos aleatorios iid, efectos aleatorios cluster, etc. Por tanto, el campo Gaussiano que tiene la anterior estructura puede también formularse según el predictor lineal del modelo como\n$$\\begin{array}{c}\r\\boldsymbol\\eta=\\beta_0\\mathbf{1} + \\boldsymbol\\beta\\mathbf{X} + \\sum_{k=1}^K f_k(\\mathbf{u}_k),\r\\end{array}\r$$ donde $(\\beta_0, \\boldsymbol\\beta)$ son los parámetros asociados a los efectos lineales, mientras que $\\{\\mathbf{f}\\}$ son funciones desconocidas de los efectos aleatorios $\\mathbf{U}=\\{\\mathbf{u}\\}$, pudiendo tener estructuras muy variadas: iid, random walk, Besag, SPDE (stochastic partial differential equation), etc.\nPartiendo de la anterior expresión, podemos reformularla en términos matriciales $\\boldsymbol\\eta=\\mathbf{A}_j\\mathbf{u}_j$, donde se ligan los efectos $(\\mathbf{u}_j)$ con el predictor de las observaciones $(\\boldsymbol\\eta)$ a través de una matriz de proyección $(\\mathbf{A}_j)$ relativa a cada efecto $(\\mathbf{u}_j)$. Esta matriz de proyección incorpora los pesos asociadas a los efectos, por ejemplo los valores de las variables explicativas para los efectos lineales, pesos asociados a estructuras de suavizado o pesos asociados a SPDEs. Es decir, podemos re-escribirlo como\n$$\r\\boldsymbol\\eta=\\left(\r\\begin{array}{c}\r\\boldsymbol\\eta_1\\\\ \\hline\r\\vdots \\\\ \\hline \\boldsymbol\\eta_J\r\\end{array}\\right)=\\left(\r\\begin{array}{c|c|c|c}\r\\mathbf{A}_1 \u0026 \\mathbf{0} \u0026 \\cdots \u0026 \\mathbf{0}\\\\ \\hline\r\\mathbf{0} \u0026 \\mathbf{A}_2 \u0026 \\cdots \u0026 \\mathbf{0}\\\\ \\hline \\mathbf{0} \u0026 \\mathbf{0} \u0026 \\cdots \u0026 \\mathbf{A}_J\r\\end{array}\\right) \\left(\r\\begin{array}{c}\r\\mathbf{u}_1\\\\ \\hline\r\\mathbf{u}_2 \\\\ \\hline\r\\vdots \\\\ \\hline \\mathbf{u}_J\r\\end{array}\\right),\r$$ donde cada efecto $\\mathbf{u}_j:j\\in (1,...,J)$ está ligado a su correspondiente matriz de proyección $\\mathbf{A}_j$.\nArtículos Fundamentales Bakka, H., Rue, H., Fuglstad, G.-A., Riebler, A. I., Bolin, D., Illian, J., Krainski, E., Simpson, D. P., \u0026 Lindgren, F. K. (2018). Spatial modelling with INLA: A review. In Wires (Vol. xx, Issue Feb). https://doi.org/10.1002/wics.1443\rLindgren, F., Rue, H., \u0026 Lindström, J. (2011). An explicit link between gaussian fields and gaussian markov random fields: The stochastic partial differential equation approach. Journal of the Royal Statistical Society. Series B: Statistical Methodology, 73(4). https://doi.org/10.1111/j.1467-9868.2011.00777.x\rLindgren, F., \u0026 Rue, H. (2015). Bayesian spatial modelling with R-INLA. Journal of Statistical Software, 63(19). https://doi.org/10.18637/jss.v063.i19\rRue, H., Martino, S., \u0026 Chopin, N. (2009). Approximate Bayesian inference for latent Gaussian models by using integrated nested Laplace approximations. Journal of the Royal Statistical Society. Series B: Statistical Methodology, 71(2). https://doi.org/10.1111/j.1467-9868.2008.00700.x\rRue, H., Riebler, A., Sørbye, S., Illian, J., Simpson, D. \u0026 Lindgren, F. (2017). Bayesian Computing with INLA: A Review. Annual Review of Statistics and Its Application, 4:1, 395-421. https://doi.org/10.1146/annurev-statistics-060116-054045\rLibros Blangiardo, M., \u0026 Cameletti, M. (2015). Spatial and Spatio-temporal Bayesian Models with R - INLA. In Spatial and Spatio-temporal Bayesian Models with R - INLA. Wiley. https://doi.org/10.1002/9781118950203\rGómez-Rubio, V. (2020). Bayesian Inference with INLA. In Bayesian Inference with INLA. Chapman \u0026 Hall/CRC Press. https://doi.org/10.1201/9781315175584\rMoraga, P. (2019). Geospatial Health Data. Chapman and Hall/CRC. https://doi.org/10.1201/9780429341823\rKrainski, E., Gómez-Rubio, V., Bakka, H., Lenzi, A., Castro-Camilo, D., Simpson, D., Lindgren, F., \u0026 Rue, H. (2018). Advanced Spatial Modeling with Stochastic Partial Differential Equations Using R and INLA. In Advanced Spatial Modeling with Stochastic Partial Differential Equations Using R and INLA. https://doi.org/10.1201/9780429031892\rRue, H., \u0026 Held, L. (2005). Gaussian Markov Random Fields. Chapman and Hall/CRC. https://doi.org/10.1201/9780203492024\rXiaofeng Wang, Ryan Yue, \u0026 Faraway, J. J. (2018). Bayesian Regression Modeling with INLA. Chapman \u0026 Hall.\r",
    "description": "",
    "tags": null,
    "title": "INLA",
    "uri": "/es/inla/index.html"
  },
  {
    "content": "En este apartado expondremos distintas funciones y operaciones básicas, que son fundamentales para la modelización con INLA.\nModelos Lineales SimplesEjemplos simples de modelos lineales.\n",
    "description": "Lista de hijos de la página",
    "tags": null,
    "title": "Operaciones Básicas",
    "uri": "/es/inla/basicoperationalinfo/index.html"
  },
  {
    "content": "Esta sección está dedicada específicamente al paquete dirinla que está construido sobre el enfoque implementado en R-INLA. Para que los ejemplos resulten comprensibles dedicaremos esta espacio introductorio para sintetizar los fundamentos matemáticos y operativos de dirinla. Esto es, realizaremos una síntesis del artículo (Martínez-Minaya et al., 2023) en el que se presenta el paquete y también se evaluarán algunas de las funciones que lo integran, modificándolas allí donde se considere pertinente.\n",
    "description": "Datos Dirichlet simulados ajustados con un modelo de efectos iid aleatorios.",
    "tags": null,
    "title": "Ejemplos con efectos iid aleatorios",
    "uri": "/es/inla/extensions/dirinla/unstructure_random_effects/index.html"
  },
  {
    "content": "Metodología inlabru ",
    "description": "",
    "tags": null,
    "title": "inlabru",
    "uri": "/es/inlabru/index.html"
  },
  {
    "content": " Información de versiones En este rótulo inicial exponemos una lista con las versiones de los programas, sistema operativo y librearías con las que se ha ejecutado el código de la presente sección, lo cual se extrae principalmente mediante la función sessionInfo().\nSO (version): Windows 11 Home (22H2). R: 4.2.2 (2022-10-31 ucrt). RStudio: 2022.07.2 (Build 576). Libraries: INLA: INLA_22.05.07 inlabru: inlabru_2.5.3 sp: sp_1.5-0 sf: sf_1.0-8 ggplot: ggplot2_3.3.6 viridis: viridis_0.6.2 Puden darse casos en los que se requiera trabajar con elementos de inla como si fuesen objetos espaciales (usualmente sp o sf), esto será particularmente propia cuando se trabajen con las mallas o los bordes de las mismas. Sea cualesquiera los motivos por los que se requiera pasar la malla o los bordes de la misma a objetos espaciales, no se dispone de una función integrada en library(INLA), por lo que se procederá a su definición.\nMalla a objeto espacial Supongamos que partimos de un conjunto de puntos dados por el data frame XY, sobre el cual aplicamos la función inla.nonconvex.hull para obtener la frontera de nuestra malla, resultado de las operaciones morfológicas de dilatación y cierre incorporadas para la formación del borde exterior.\nGet XY data library(INLA) library(inlabru) XY \u003c- readRDS(file=\"XY.rds\") INLAnonconvex \u003c- inla.nonconvex.hull(XY, convex=1000, resolution=400) INLAnonconvexMesh \u003c- inla.mesh.2d(boundary=INLAnonconvex, max.edge=5000) Si graficamos la malla ggplot() + inlabru::gg(INLAnonconvexMesh) + theme_void() obtendremos la siguiente figura:\nFig. 1: INLA mesh with non convex boundary Una vez se dispone de la malla, para transformar la teselación en un objeto espacial (sp) nos valemos de la información integrada en el objeto de la malla (mesh). Concretamente en las filas de la matriz mesh$graph$tv, que almacenan las posiciones de los vértices para cada i-ésimo triángulo. De esta forma, simplemente inscribimos los índices de los vértices para cada triángulo en la matriz de coordenadas de los propios vértices, formando un polígono con cada uno y agrupandando finalmente el resultado en un objeto SpatialPolygons, o en un Esto queda sintetizado en la siguiente función:\nsp sf SpatialPolygonDelaunay \u003c- function(mesh){ return(SpatialPolygons(sapply(1:nrow(mesh$graph$tv), function(i){ list(Polygons(list(Polygon(mesh$loc[mesh$graph$tv[i,],1:2])),i )) }) )) } SpatialPolygonDelaunay \u003c- function(mesh){ return(st_polygon(sapply(1:nrow(mesh$graph$tv), function(i){ list(mesh$loc[c(mesh$graph$tv[i,], mesh$graph$tv[i,1]),1:2]) }) )) } Tal que el objeto ya convertido lo tendríamos como:\nSpatialPolygonMesh \u003c- SpatialPolygonDelaunay(mesh=INLAnonconvexMesh) Borde a objeto espacial En este caso se pretendenden transformar los bordes de la malla a SpatialPolygons, de tal forma que se pueda dar cuenta de los huecos presentes en la misma. Entonces, lo primero a realizar es convertir los bordes en polígonos simplemente conexos (sin huecos).\nPara conformar correctamente un polígono se debe indicar el orden de sucesión de los puntos del perímetro del mismo, tal que el el primer punto sea también el último para cerrar el polígono. Esto se puede realizar fácilmente gracias a que la malla almacena las localizaciones de los vértices que componen los bordes como pares de puntos en las filas de la matriz mesh$segm$bnd$idx. Esto es, si los puntos se refieren al mismo polígono tendremos la conexión establecida a partir de los pares de índices recorriendo las filas de esta matriz, tal que se llegará a repetir en la primera columna la posición del punto inicial para cerrar el polígono.\nPor tanto, sabiendo que la secuencia de índices para cada curva cerrada implica que el último par acabe en el primer punto (primer par de índices), tendremos que el elemento de la primera columna de la siguiente fila será diferente del elemento de la segunda columna de la fila de referencia: mesh$segm$bnd$idx[i+1,1]!=mesh$segm$bnd$idx[i,1]. Por lo que, a través de esta condición, podemos establecer los índices de los límites de los polígonos que querremos reconstruir como objetos espaciales (sp o sf).\nsp sf SpatialPolygonsBoundary \u003c- function(mesh){ BoundaryIndx \u003c- sapply(1:(nrow(mesh$segm$bnd$idx)-1), function(i){ return(mesh$segm$bnd$idx[i+1,1]==mesh$segm$bnd$idx[i,2]) }) BoundaryIndxLims \u003c- which(!BoundaryIndx) BoundaryIndxLims \u003c- c(0, BoundaryIndxLims, nrow(mesh$segm$bnd$idx)) SpatialPolygonsBoundary \u003c- SpatialPolygons(sapply(2:(length(BoundaryIndxLims)), function(i){ VertixBoundaryIndex \u003c- matrix(c(mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1):BoundaryIndxLims[i],1], mesh$segm$bnd$idx[BoundaryIndxLims[i],2]), ncol=1, byrow=TRUE) return(list(Polygons(list(Polygon(mesh$loc[VertixBoundaryIndex,1:2])),i))) })) return(SpatialPolygonsBoundary) } SpatialPolygonsBoundary \u003c- function(mesh){ BoundaryIndx \u003c- sapply(1:(nrow(mesh$segm$bnd$idx)-1), function(i){ return(mesh$segm$bnd$idx[i+1,1]==mesh$segm$bnd$idx[i,2]) }) BoundaryIndxLims \u003c- which(!BoundaryIndx) BoundaryIndxLims \u003c- c(0, BoundaryIndxLims, nrow(mesh$segm$bnd$idx)) SpatialPolygonsBoundary \u003c- st_polygon(sapply(2:(length(BoundaryIndxLims)), function(i){ VertixBoundaryIndex \u003c- c(mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1),1], mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1):BoundaryIndxLims[i],2]) return(list(cbind(mesh$loc[VertixBoundaryIndex,1:2]))) })) return(SpatialPolygonsBoundary) } Entonces, una vez se han conformado todos los polígonos a partir de los bordes dados por la función de INLA, se deben transformar estos polígonos para dar cuenta de los huecos que puedan contener y están presentes. Para ello podemos realizar una planteamiento matemático de las propiedades del problema, empleando teoría de conjuntos para conjuntos ordenados, o bien plantearlo de forma operacional para su resolución.\nPlantemiento operacional. Para realizarlo según un plateamiento operacional debemos considerar que hemos formado un polígono por cada curva cerrada, por cada borde o frontera, de tal forma que estas curvas podrán contener en su interior a otras superficies dadas por otras curvas. Además, algunos de estos polígonos podrán estar asociados al borde interior de los polígonos, los cuales remitirían a la frontera del hueco interno de dicho polígono, tal que podremos tener clasificar los polígonos obtenidos en dos clases o tipos: polígonos llenos y polígonos huecos, según remitan al borde de un área “llena” o un área “hueca”. Además, se tiene que tener en cuenta que un polígono lleno contendrán en el siguiente nivel de intersección máxima interna, en caso de contener en su interior otros polígonos, un polígono hueco. Mientras que para el caso de los polígonos huecos esta condición supone la contrarecíproca; a saber, que el siguiente nivel de intersección máxima interna será un polígono lleno. Tal que el nivel de interseccionalidad máxima interna respecto de un polígono dado lo entenderemos como el polígono de mayor área que esté completamente contenido en el polígono de referencia. Pero podemos ampliar esta definición según los distintos conjuntos de polígonos mutuamente independientes, donde la interseccionalidad máxima interna para el polígono de referencia ya no sea un único polígono, sino el mayor polígono de cada uno de estos conjuntos mutuamente disjuntos.\nPor otro lado, si un polígono, delimitado por una de estas curvas dadas, tiene una intersección no nula con otros, entonces esta intersección reproducirá totalmente uno de los dos polígonos.\nPosteriormente, si análogamente a una matriz de adyacencia o vecindad, elaboramos una matriz de interseccionalidad, determinada según la operación de intersección de un polígono dado sobre el resto de polígonos. Tal que la matriz contendrá las relaciones entre un polígono dado con todo el conjunto de polígonos según la operación de intersección, operación que valdrá 1 si hay intersección y 0 si no la hay. Por tanto, por cada fila o columna obtendremos la intersección de un polígono con el resto, donde la diagonal de la matriz manifestaría la intersección de un polígono consigo mismo, por lo que la diagonal principal será un vector de unos.\nDe la matriz de interseccionalidad podemos concluir que las filas o columnas cuya suma resulte unitaria (únicamente el elemento de la diagonal principal resultará distinto de 0 para esa fila o columna), pertenecerán a un polígono que no contendrá ningún otro polígono, sea este hueco o lleno. Por tanto, podríamos extraer estos polígonos como polígonos correctamente definidos y que no requieren de transformación alguna.\nFinalmente, en caso de que una fila dada sume más de uno implicará que, al menos, contiene un hueco. Por lo que para formar los polígonos con los huecos podemos plantear el procedimiento de la siguiente forma:\nPrimero, para cada fila se puede buscar el polígono de menor tamaño (área) en todo el conjunto de polígonos intersectantes, a partir del cual se construirá un conjunto completamente ordenado según las intersecciones del mismo. Seguidamente, se puede recomponer el conjunto de polígonos como la reordenación en la menor cantidad de conjuntos totalmente ordenados. Tal que de estos conjuntos totalmente ordenados sabremos que el mayor de los conjuntos remite a un polígono lleno, el siguiente a uno hueco, … y así sucesivamente. Para en tercer lugar, conformar mediante operaciones de diferencia y unión los distintos polígonos que den cuenta de los huecos existentes. Plantemiento matemático. Desde un enfoque matemático podemos emplear teoría de conjuntos para evaluar el conjunto de operaciones a realizar para resolver la cuestión. Para ello, lo primero que debemos hacer es establecer las condiciones del problema:\nTenemos un conjunto de $n$ polígonos $p_i$, tal que el conjunto universal de referencia será $\\displaystyle P=\\{p_1, …, p_n\\}$. Tal que estos polígonos son subconjuntos del espacio Euclídeo de dos dimensiones, $p_i\\subset \\mathbb{R}^2$. Existen dos tipos de polígonos: (i) polígonos llenos (o fill) $P_{F}=\\{p_{fi}\\}$ y (ii) polígonos huecos (o holes) $P_H=\\{p_{hi}\\}$, tal que $P=P_F\\cup P_H$. Existe una función $f$ que establece la relación entre un polígono $p_i$ con su área $a_i$, tal que $f:P\\longmapsto A$ es $f(p_i)=a_i$. No obstante, esta función es sólo sobreyectiva si asumimos que puede haber dos o más polígonos con la misma área, mientras que sería sobreyectiva e inyectiva si para cada polígono tiene un área distinta. Si la intersección de dos polígonos es no nula, entonces la intersección resulta en el polígono de menor área. Esto es, $p_i\\cap p_j=\\{\\emptyset\\veebar p_j\\}|f(p_i)\u003ef(p_j)$. Además, tenemos como condición que no existe ningún polígono que intersectando con otro tenga su misma área, $(\\nexists p_i)(p_i,p_j\\in P): f(p_i)=f(p_j)\\iff \\{p_i\\cap p_j\\neq \\emptyset \\wedge i\\neq j\\}$. Para el conjunto de todas las intersecciones no nulas de polígonos $(p_i, p_j)$, tendremos que el conjunto con mayor área es un polígono lleno $f(p_i)\u003ef(p_j):p_i\\in P_F$. Finalmente, como condición debil entre la intersección no nula de dos polígonos llenos, tenemos que existe, al menos, un polígono hueco con mayor área que la del polígono lleno de menor área y que también intersecta con los mismos. Dicho de otro modo, si $p_j\\subset p_i:p_i,p_j\\in P_F\\Rightarrow (\\exists p_k) p_k\\in P_H: p_j\\subset p_k\\subset p_i$. Mientras que la condición fuerte será, que si tenemos dos polígonos tal que uno es subconjunto de otro sin nungún polígono lleno que puede incorporarse como elemento medio entre ambos mediante la operación de subconjunto-de, entonces existe un y sólo un polígono hueco que intermedia entre ambos: $$(\\forall p_i,p_j\\in P_F) p_j\\subset p_i:\\nexists p_k\\in P_F, p_j \\subset p_k \\wedge p_k\\subset p_i \\iff \\exists! p_z\\in P_H: p_j\\subset p_z \\wedge p_z\\subset p_i.$$\rDadas estas condiciones es obvio que puede reordenarse el conjunto $P$ de todos los polígonos, de tal forma que tengamos el menor número de conjuntos completamente ordenados de mayor cardinalidad cuya unión reproduzca el conjunto $P$ de referencia. Es decir, tenemos que conformar todos aquellos conjuntos completamente ordenados $(P_i,\\subset)$, lo cual implica que $(\\forall p_i) p_i\\in P_i (\\exists p_j)p_j\\in P_i\\rightarrow p_j\\subset p_i \\vee p_i\\subset p_j$. Por tanto, debemos construir estos conjuntos completamente ordenados $P_i=\\{p_{i1}\\subset p_{2i}\\subset … \\subset p_{ni}\\}$, de los que sabemos por las condiciones (5) y (6) que para cualquiera de estos conjuntos $P_i$, tendremos que los polígonos llenos serán:\n$$\\{p_{ki},p_{(k-2)i},...,\\}\\in P_F \\Rightarrow p_{(k-2m)i}\\in P_F:m\\in M\\subset\\mathbb{N},$$\rmientras que los polígonos huecos serían: $$\\{p_{(k-1)i},p_{(k-3)i},...,\\}\\in P_H \\Rightarrow p_{(k-1-2m)i}\\in P_H: m\\in M'\\subset\\mathbb{N}.$$\rEl código para poder realizar las transformaciones pertinentes y obtener los polígonos con los huecos correspondientes, es el siguiente:\nsp CompleteOrderedSetsFromSpatialPolygonsClass \u003c- function(SPDINLAnonconvexBoundary){ SPDINLABoundaryList \u003c- list(Polygons=list(), DFIDArea=data.frame(matrix(ncol=2,nrow=0, dimnames=list(NULL, c(\"ID\", \"Area\")))) ) for(i in 1:length(SPDINLAnonconvexBoundary)){ SPDINLABoundaryList$Polygons[[i]] \u003c- SPDINLAnonconvexBoundary[i] SPDINLABoundaryList$DFIDArea[i,] \u003c- c(i, SPDINLAnonconvexBoundary[i]@polygons[[1]]@area) } IndexIDV \u003c- SPDINLABoundaryList$DFIDArea$ID ConnectivityMatrix \u003c- matrix(ncol=length(SPDINLAnonconvexBoundary), nrow=length(SPDINLAnonconvexBoundary)) for(i in 1:length(SPDINLAnonconvexBoundary)){ for(j in i:length(SPDINLAnonconvexBoundary)){ ConnectivityMatrix[i,j] \u003c- ConnectivityMatrix[j,i] \u003c- as.numeric(gIntersects(SPDINLAnonconvexBoundary[i], SPDINLAnonconvexBoundary[j])) } } IndexIsolatedPolygonFill \u003c- which(apply(ConnectivityMatrix, FUN=sum, MARGIN=1)==1) IndexIDV \u003c- if(length(IndexIsolatedPolygonFill)==0){IndexIDV} else{IndexIDV[-which(apply(ConnectivityMatrix, FUN=sum, MARGIN=1)==1)]} CompleteOrderedSets \u003c- list(CompleteOrderedSets=list(), DFCompleteOrderedSets=list(), CompleteOrderedIsolatedSets=list(), DFCompleteOrderedIsolatedSets=list()) if(length(IndexIsolatedPolygonFill)!=0){ for(i in 1:length(IndexIsolatedPolygonFill)){ CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]] \u003c- SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]] CompleteOrderedSets$DFCompleteOrderedIsolatedSets[[i]] \u003c- data.frame(ID=SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]]@polygons[[1]]@ID, Area=SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]]@polygons[[1]]@area, HOLE=FALSE) } } if(length(IndexIsolatedPolygonFill)!=length(IndexIDV)){ n_step \u003c- 1 while(length(IndexIDV)!=0){ IDminArea \u003c- SPDINLABoundaryList$DFIDArea[IndexIDV,\"ID\"][which.min(SPDINLABoundaryList$DFIDArea[IndexIDV,\"Area\"])] IndxCOS \u003c- which(as.logical(ConnectivityMatrix[IDminArea,])) DFIDAreaV \u003c- SPDINLABoundaryList$DFIDArea[IndxCOS,] CompleteOrderedSets$CompleteOrderedSets[[n_step]] \u003c- SpatialPolygons(sapply(DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"ID\"], function(i){ list(SPDINLABoundaryList$Polygons[[i]]@polygons[[1]]) }) ) CompleteOrderedSets$DFCompleteOrderedSets[[n_step]] \u003c- data.frame(ID=DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"ID\"], Area=DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"Area\"], HOLE=floor(1:length(IndxCOS)/2)==1:length(IndxCOS)/2 ) IndexIDV \u003c- setdiff(IndexIDV,IndxCOS) n_step \u003c- n_step+1 } SpatialPolygonsNames \u003c- c() for(i in 1:length(CompleteOrderedSets$CompleteOrderedSets)){ if(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2!=floor(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2)){ SpatialPolygonsNames \u003c- c(SpatialPolygonsNames, paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[length(CompleteOrderedSets$CompleteOrderedSets[[i]])])) assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[length(CompleteOrderedSets$CompleteOrderedSets[[i]])]), value=SpatialPolygons(list( CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[length(CompleteOrderedSets$CompleteOrderedSets[[i]])]] ))) } for(j in 1:floor(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2)){ indx \u003c- 1:2+2*(j-1) if(exists(paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]))){ assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]), value=gDifference(eval(parse(text=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]))), SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[2]]])), id=paste0(CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]) ) ) } else{ SpatialPolygonsNames \u003c- c(SpatialPolygonsNames, paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]])) assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]), value=gDifference(SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[1]]])), SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[2]]])), id=paste0(CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]) ) ) }} if(length(IndexIsolatedPolygonFill)!=0){ SpatialPolygonRefined \u003c- SpatialPolygons(c(lapply(1:length(SpatialPolygonsNames), function(i){ return(eval(parse(text=paste0(SpatialPolygonsNames[i], \"@polygons[[1]]\")))) }), lapply(1:length(CompleteOrderedSets$CompleteOrderedIsolatedSets), function(i){ return(CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]]@polygons[[1]]) }))) } else{ SpatialPolygonRefined \u003c- SpatialPolygons(lapply(1:length(SpatialPolygonsNames), function(i){ return(eval(parse(text=paste0(SpatialPolygonsNames[i], \"@polygons[[1]]\")))) })) } } } else{ SpatialPolygonRefined \u003c- SpatialPolygons(lapply(1:length(CompleteOrderedSets$CompleteOrderedIsolatedSets), function(i){ return(CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]]@polygons[[1]]) })) } SpatialPolygonRefined@proj4string \u003c- CRS(\"+proj=utm\") CompleteOrderedSetsAndPolygons \u003c- list(CompleteOrderedSets=CompleteOrderedSets, SpatialPolygonRefined=SpatialPolygonRefined) return(CompleteOrderedSetsAndPolygons) } Gracias a esta función tenemos todos los polígonos según las curvas cerradas que los determinan. Esto permite que se puedan realizar operaciones mediante ellos, de tal forma que se esté teniendo en cuenta los huecos existentes.\nPor tanto, siguiendo el ejemplo, tendríamos que aplicar la primera función SpatialPolygonsBoundary sobre el resultado de la malla INLAnonconvexMesh, y posteriormente aplicar la función que acabamos de definir.\nSPDINLAnonconvexBoundary \u003c- SpatialPolygonsBoundary(mesh = INLAnonconvexMesh) PolygonsRefined \u003c- CompleteOrderedSetsFromSpatialPolygonsClass(SPDINLAnonconvexBoundary = SPDINLAnonconvexBoundary) Para que se visualice que propiamente ahora tenemos la totalidad de los polígonos disponibles unos independientes de otros, podemos graficarlos mediante diferentes colores:\ncol \u003c- viridis::turbo(length(PolygonsRefined$SpatialPolygonRefined)) ggplotPolygons \u003c- ggplot() for(i in 1:length(PolygonsRefined$SpatialPolygonRefined)){ ggplotPolygons \u003c- ggplotPolygons + geom_sf(data=st_as_sf(PolygonsRefined$SpatialPolygonRefined[i]), fill=col[i], alpha=0.5) } Tal que, si representamos los polígonos como ggplotPolygons + theme_void() obtendremos la siguiente figura:\nFig. 2: Refined polygons Ejemplo con polígonos apilados. Vamos a presentar un pequeño ejemplo para que se visualice que la función es capaz de extraer un orden arbitrario de polígonos, aunque estos estén apilados. Es decir, en principio, la función aplica para cualquier caso en general que cumpla con dos condiciones, (i) la intersección total y (ii) la ordenación de polígono-lleno / polígono-hueco en niveles sucesivos de intersección máxima interna.\nLo primero que haremos para comprobar que dicha función es capaz de operar con polígonos apilados será crear los polígonos:\nrho1 \u003c- rnorm(120,1,0.01); theta1 \u003c- runif(120,0,2*pi) rho2 \u003c- rnorm(120,6,0.01); theta2 \u003c- runif(120,0,2*pi) rho3 \u003c- rnorm(220,12,0.01); theta3 \u003c- runif(220,0,2*pi) XYPoint \u003c- as.matrix(rbind( cbind(rho1*cos(theta1), rho1*sin(theta1)), cbind(rho2*cos(theta2), rho2*sin(theta2)), cbind(rho3*cos(theta3), rho3*sin(theta3)) )) Boundary \u003c- inla.nonconvex.hull(points=XYPoint, convex=1, resolution=c(100,100)) INLAnonconvexMesh \u003c- inla.mesh.2d(boundary=Boundary, max.edge=1) SPDINLAnonconvexBoundary \u003c- SpatialPolygonsBoundary(mesh=INLAnonconvexMesh) Fig. 3: Nested polygons Fig. 4: Mesh of nested polygons A continuación aplicacamos la función para extraer los polígonos con los huecos y representamos gráficamente el resultado:\nPolygonsRefined \u003c- CompleteOrderedSetsFromSpatialPolygonsClass(SPDINLAnonconvexBoundary=SPDINLAnonconvexBoundary) col \u003c- viridis::turbo(length(PolygonsRefined$SpatialPolygonRefined)) ggplotPolygons \u003c- ggplot() for(i in 1:length(PolygonsRefined$SpatialPolygonRefined)){ ggplotPolygons \u003c- ggplotPolygons + geom_sf(data=st_as_sf(PolygonsRefined$SpatialPolygonRefined[i]), fill=col[i], alpha=0.5) } Fig. 5: Nested polygons fixing holes ",
    "description": "Aquí definimos algunas funciones relativas a la transformación de un objeto inla.mesh a un objeto sp/sf.",
    "tags": null,
    "title": "Transformación a sp/sf",
    "uri": "/es/inla/variousfunctions/inlatosp/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/es/categories/index.html"
  },
  {
    "content": "Esta sección está dedicada específicamente al paquete dirinla que está construido sobre el enfoque implementado en R-INLA. Para que los ejemplos resulten comprensibles dedicaremos esta espacio introductorio para sintetizar los fundamentos matemáticos y operativos de dirinla. Esto es, realizaremos una síntesis del artículo (Martínez-Minaya et al., 2023) en el que se presenta el paquete y también se evaluarán algunas de las funciones que lo integran, modificándolas allí donde se considere pertinente.\nEjemplos Ejemplos con efectos fijosDatos Dirichlet simulados ajustados con un modelo de efectos fijos.\nEjemplos con efectos iid aleatoriosDatos Dirichlet simulados ajustados con un modelo de efectos iid aleatorios.\nEjemplos con efectos aleatorios espacialmente estructuradosDatos Dirichlet simulados ajustados con un modelo de efectos aleatorios espacialmente estructurados.\nINLA for Fitting Dirichlet Regression Models (Resumen) Este es un breve resumen del artículo (Martínez-Minaya et al., 2023) en el que se presenta la metodología en la que se basa el paquete, junto con algunos casos de estudio y comparativas con métodos MCMC, concretamente empleando JAGS.\nEvaluación y Modificación de funciones Referencias Joaquín Martínez-Minaya, Finn Lindgren, Antonio López-Quílez, Daniel Simpson \u0026 David Conesa (2023) The Integrated Nested Laplace Approximation for Fitting Dirichlet Regression Models, Journal of Computational and Graphical Statistics, 32:3, 805-823, DOI: https://doi.org/10.1080/10618600.2022.2144330 Depaoli, S., Clifton, J. P., \u0026 Cobb, P. R. (2016). Just Another Gibbs Sampler (JAGS): Flexible Software for MCMC Implementation. Journal of Educational and Behavioral Statistics, 41(6), 628–649. http://www.jstor.org/stable/26447820 ",
    "description": "Ejemplos empleando el paquete dirinla para Datos Composicionales (CoDa).",
    "tags": null,
    "title": "dirinla",
    "uri": "/es/inla/extensions/dirinla/index.html"
  },
  {
    "content": "Esta sección está dedicada específicamente al paquete dirinla que está construido sobre el enfoque implementado en R-INLA. Para que los ejemplos resulten comprensibles dedicaremos esta espacio introductorio para sintetizar los fundamentos matemáticos y operativos de dirinla. Esto es, realizaremos una síntesis del artículo (Martínez-Minaya et al., 2023) en el que se presenta el paquete y también se evaluarán algunas de las funciones que lo integran, modificándolas allí donde se considere pertinente.\n",
    "description": "Datos Dirichlet simulados ajustados con un modelo de efectos aleatorios espacialmente estructurados.",
    "tags": null,
    "title": "Ejemplos con efectos aleatorios espacialmente estructurados",
    "uri": "/es/inla/extensions/dirinla/spde2_random_effects/index.html"
  },
  {
    "content": "En esta sección realizamos una pequeña recopilación de paquetes o librerías que resultan en extensiones del paquete R-INLA.\ndirinlaEjemplos empleando el paquete dirinla para Datos Composicionales (CoDa).\n",
    "description": "Sección para extensiones de INLA en otras librerías o paquetes.",
    "tags": null,
    "title": "Extensiones de INLA",
    "uri": "/es/inla/extensions/index.html"
  },
  {
    "content": "Aquí se expondran distintas funciones que se han ido desarrollando para su implementación en procesos automatizados o que puedan resultar de interés.\nTransformación a sp/sfAquí definimos algunas funciones relativas a la transformación de un objeto inla.mesh a un objeto sp/sf.\n",
    "description": "List the child pages of a page",
    "tags": null,
    "title": "Funciones Varias",
    "uri": "/es/inla/variousfunctions/index.html"
  },
  {
    "content": "En esta sección expondremos\n",
    "description": "Un modelo geoestadístico simple en INLA.",
    "tags": null,
    "title": "Modelo Geoestadístico",
    "uri": "/es/inla/spatialmodels/geostatisticalmodel/index.html"
  },
  {
    "content": "In this section we will show\n",
    "description": "Un modelo conjunto para datos prefenciales.",
    "tags": null,
    "title": "Modelo Preferencial",
    "uri": "/es/inla/spatialmodels/jointmodel_preferential/index.html"
  },
  {
    "content": "En esta sección expondremos cómo realizar distintos tipos de modelos espaciales con INLA en el entonrno R-INLA:\n",
    "description": "Modelos de Coeficientes Espacialmente Variables.",
    "tags": null,
    "title": "Modelo SVC",
    "uri": "/es/inla/spatialmodels/spatialvaryingcoefficientmodel/index.html"
  },
  {
    "content": "En esta sección expondremos cómo realizar distintos tipos de modelos espaciales con INLA en el entorno R-INLA:\nModelo GeoestadísticoUn modelo geoestadístico simple en INLA.\nModelo PreferencialUn modelo conjunto para datos prefenciales.\nModelo SVCModelos de Coeficientes Espacialmente Variables.\n",
    "description": "Sección para los Modelos Espaciales (SPDE-FEM).",
    "tags": null,
    "title": "Modelos Espaciales (SPDE-FEM)",
    "uri": "/es/inla/spatialmodels/index.html"
  },
  {
    "content": "En esta sección se expondrán distintos ejemplos de modelos sencillos con datos simulados, para así ejemplificar cómo operar con R-INLA.\n",
    "description": "Ejemplos simples de modelos lineales.",
    "tags": null,
    "title": "Modelos Lineales Simples",
    "uri": "/es/inla/basicoperationalinfo/linearmodels/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/es/tags/index.html"
  }
]
