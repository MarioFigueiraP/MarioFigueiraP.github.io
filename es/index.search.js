var relearn_search_index = [
  {
    "content": "Introducción En esta GitHub Page se expondrán cuestiones relativas a estadística bayesiana y modelización con un doble propósito. Primeramente, como un modo de organizar el material que voy desarrollando a lo largo de distintos proyectos y del doctorado. En segundo lugar, como posible apoyo para aquellos interesados en este campo, por si este material resultara de algún interés y ayuda.\nLos principales temas que se podrán encontrar aquí están relacionados con:\nINLA (Integrated Nested Laplace Approximation) MCMC (Markov Chain Monte Carlo) Modelización jerárquica Modelización espacial Modelización temporal Modelización espacio temporal Aplicaciones Shiny Con el fin de ceñirnos a una metodología en el que la replicabilidad y reproducción de los resultados obtenidos es absolutamente perentoria, se indica al inicio de cada sección el sistema operativo, la versión del lenguaje de programación, del entorno de programación para dicho lenguaje, junto con el código y datos empleados. No obstante, tan sólo esto muchas veces podrá ser insuficiente, por lo que dependiendo del código implementado pueda requerirse el indicar la versión de paquetes, librerías o bibliotecas usadas en cada caso.\nSobre mí Resumen Una imagen Mi nombre es Mario Figueira y soy un estudiante de doctorado en Estadística y Optimización por la Universidad de Valencia, concretamente mi línea de investigación se centra en modelización Bayesiana espacio-temporal. ",
    "description": "",
    "tags": null,
    "title": "Inicio",
    "uri": "/es/index.html"
  },
  {
    "content": "Metodología INLA Existen distintas metodologías para la computación de los procesos beyesianos de inferencia, métodos de simulación como MCMC (Markov chain Monte Carlo) o métodos aproximativos como VB (variational Bayes), todas ellas con sus dificultades propias. En particular, INLA (Integrated Nested Laplace Approximation) es un enfoque determinista aproximado, desarrollado por (Rue, Martino y Chopin, 2009) y ampliado en (Lindgren y Rue, 2015; Rue y col., 2017; Bakka y col., 2018), que permite realizar la inferencia Bayesiana en un conjunto de modelos aditivos estructurados, denominados modelos Gaussianos latentes (LGMs).\n",
    "description": "",
    "tags": null,
    "title": "INLA",
    "uri": "/es/inla/index.html"
  },
  {
    "content": " Información de versiones En este rótulo inicial exponemos una lista con las versiones de los programas, sistema operativo y librearías con las que se ha ejecutado el código de la presente sección, lo cual se extrae principalmente mediante la función sessionInfo().\nSO (version): Windows 11 Home (22H2). R: 4.2.2 (2022-10-31 ucrt). RStudio: 2022.07.2 (Build 576). Libraries: INLA: INLA_22.05.07 inlabru: inlabru_2.5.3 sp: sp_1.5-0 sf: sf_1.0-8 ggplot: ggplot2_3.3.6 viridis: viridis_0.6.2 Puden darse casos en los que se requiera trabajar con elementos de inla como si fuesen objetos espaciales (usualmente sp o sf), esto será particularmente propia cuando se trabajen con las mallas o los bordes de las mismas. Sea cualesquiera los motivos por los que se requiera pasar la malla o los bordes de la misma a objetos espaciales, no se dispone de una función integrada en library(INLA), por lo que se procederá a su definición.\nMalla a objeto espacial Supongamos que partimos de un conjunto de puntos dados por el data frame XY, sobre el cual aplicamos la función inla.nonconvex.hull para obtener la frontera de nuestra malla, resultado de las operaciones morfológicas de dilatación y cierre incorporadas para la formación del borde exterior.\nGet XY data library(INLA) library(inlabru) XY \u003c- readRDS(file=\"XY.rds\") INLAnonconvex \u003c- inla.nonconvex.hull(XY, convex=1000, resolution=400) INLAnonconvexMesh \u003c- inla.mesh.2d(boundary=INLAnonconvex, max.edge=5000) Si graficamos la malla ggplot() + inlabru::gg(INLAnonconvexMesh) + theme_void() obtendremos la siguiente figura:\nFig. 1: INLA mesh with non convex boundary Una vez se dispone de la malla, para transformar la teselación en un objeto espacial (sp) nos valemos de la información integrada en el objeto de la malla (mesh). Concretamente en las filas de la matriz mesh$graph$tv, que almacenan las posiciones de los vértices para cada i-ésimo triángulo. De esta forma, simplemente inscribimos los índices de los vértices para cada triángulo en la matriz de coordenadas de los propios vértices, formando un polígono con cada uno y agrupandando finalmente el resultado en un objeto SpatialPolygons, o en un Esto queda sintetizado en la siguiente función:\nsp sf SpatialPolygonDelaunay \u003c- function(mesh){ return(SpatialPolygons(sapply(1:nrow(mesh$graph$tv), function(i){ list(Polygons(list(Polygon(mesh$loc[mesh$graph$tv[i,],1:2])),i )) }) )) } SpatialPolygonDelaunay \u003c- function(mesh){ return(st_polygon(sapply(1:nrow(mesh$graph$tv), function(i){ list(mesh$loc[c(mesh$graph$tv[i,], mesh$graph$tv[i,1]),1:2]) }) )) } Tal que el objeto ya convertido lo tendríamos como:\nSpatialPolygonMesh \u003c- SpatialPolygonDelaunay(mesh=INLAnonconvexMesh) Borde a objeto espacial En este caso se pretendenden transformar los bordes de la malla a SpatialPolygons, de tal forma que se pueda dar cuenta de los huecos presentes en la misma. Entonces, lo primero a realizar es convertir los bordes en polígonos simplemente conexos (sin huecos).\nPara conformar correctamente un polígono se debe indicar el orden de sucesión de los puntos del perímetro del mismo, tal que el el primer punto sea también el último para cerrar el polígono. Esto se puede realizar fácilmente gracias a que la malla almacena las localizaciones de los vértices que componen los bordes como pares de puntos en las filas de la matriz mesh$segm$bnd$idx. Esto es, si los puntos se refieren al mismo polígono tendremos la conexión establecida a partir de los pares de índices recorriendo las filas de esta matriz, tal que se llegará a repetir en la primera columna la posición del punto inicial para cerrar el polígono.\nPor tanto, sabiendo que la secuencia de índices para cada curva cerrada implica que el último par acabe en el primer punto (primer par de índices), tendremos que el elemento de la primera columna de la siguiente fila será diferente del elemento de la segunda columna de la fila de referencia: mesh$segm$bnd$idx[i+1,1]!=mesh$segm$bnd$idx[i,1]. Por lo que, a través de esta condición, podemos establecer los índices de los límites de los polígonos que querremos reconstruir como objetos espaciales (sp o sf).\nsp sf SpatialPolygonsBoundary \u003c- function(mesh){ BoundaryIndx \u003c- sapply(1:(nrow(mesh$segm$bnd$idx)-1), function(i){ return(mesh$segm$bnd$idx[i+1,1]==mesh$segm$bnd$idx[i,2]) }) BoundaryIndxLims \u003c- which(!BoundaryIndx) BoundaryIndxLims \u003c- c(0, BoundaryIndxLims, nrow(mesh$segm$bnd$idx)) SpatialPolygonsBoundary \u003c- SpatialPolygons(sapply(2:(length(BoundaryIndxLims)), function(i){ VertixBoundaryIndex \u003c- matrix(c(mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1):BoundaryIndxLims[i],1], mesh$segm$bnd$idx[BoundaryIndxLims[i],2]), ncol=1, byrow=TRUE) return(list(Polygons(list(Polygon(mesh$loc[VertixBoundaryIndex,1:2])),i))) })) return(SpatialPolygonsBoundary) } SpatialPolygonsBoundary \u003c- function(mesh){ BoundaryIndx \u003c- sapply(1:(nrow(mesh$segm$bnd$idx)-1), function(i){ return(mesh$segm$bnd$idx[i+1,1]==mesh$segm$bnd$idx[i,2]) }) BoundaryIndxLims \u003c- which(!BoundaryIndx) BoundaryIndxLims \u003c- c(0, BoundaryIndxLims, nrow(mesh$segm$bnd$idx)) SpatialPolygonsBoundary \u003c- st_polygon(sapply(2:(length(BoundaryIndxLims)), function(i){ VertixBoundaryIndex \u003c- c(mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1),1], mesh$segm$bnd$idx[(BoundaryIndxLims[i-1]+1):BoundaryIndxLims[i],2]) return(list(cbind(mesh$loc[VertixBoundaryIndex,1:2]))) })) return(SpatialPolygonsBoundary) } Entonces, una vez se han conformado todos los polígonos a partir de los bordes dados por la función de INLA, se deben transformar estos polígonos para dar cuenta de los huecos que puedan contener y están presentes. Para ello podemos realizar una planteamiento matemático de las propiedades del problema, empleando teoría de conjuntos para conjuntos ordenados, o bien plantearlo de forma operacional para su resolución.\nPlantemiento operacional. Para realizarlo según un plateamiento operacional debemos considerar que hemos formado un polígono por cada curva cerrada, por cada borde o frontera, de tal forma que estas curvas podrán contener en su interior a otras superficies dadas por otras curvas. Además, algunos de estos polígonos podrán estar asociados al borde interior de los polígonos, los cuales remitirían a la frontera del hueco interno de dicho polígono, tal que podremos tener clasificar los polígonos obtenidos en dos clases o tipos: polígonos llenos y polígonos huecos, según remitan al borde de un área “llena” o un área “hueca”. Además, se tiene que tener en cuenta que un polígono lleno contendrán en el siguiente nivel de intersección máxima interna, en caso de contener en su interior otros polígonos, un polígono hueco. Mientras que para el caso de los polígonos huecos esta condición supone la contrarecíproca; a saber, que el siguiente nivel de intersección máxima interna será un polígono lleno. Tal que el nivel de interseccionalidad máxima interna respecto de un polígono dado lo entenderemos como el polígono de mayor área que esté completamente contenido en el polígono de referencia. Pero podemos ampliar esta definición según los distintos conjuntos de polígonos mutuamente independientes, donde la interseccionalidad máxima interna para el polígono de referencia ya no sea un único polígono, sino el mayor polígono de cada uno de estos conjuntos mutuamente disjuntos.\nPor otro lado, si un polígono, delimitado por una de estas curvas dadas, tiene una intersección no nula con otros, entonces esta intersección reproducirá totalmente uno de los dos polígonos.\nPosteriormente, si análogamente a una matriz de adyacencia o vecindad, elaboramos una matriz de interseccionalidad, determinada según la operación de intersección de un polígono dado sobre el resto de polígonos. Tal que la matriz contendrá las relaciones entre un polígono dado con todo el conjunto de polígonos según la operación de intersección, operación que valdrá 1 si hay intersección y 0 si no la hay. Por tanto, por cada fila o columna obtendremos la intersección de un polígono con el resto, donde la diagonal de la matriz manifestaría la intersección de un polígono consigo mismo, por lo que la diagonal principal será un vector de unos.\nDe la matriz de interseccionalidad podemos concluir que las filas o columnas cuya suma resulte unitaria (únicamente el elemento de la diagonal principal resultará distinto de 0 para esa fila o columna), pertenecerán a un polígono que no contendrá ningún otro polígono, sea este hueco o lleno. Por tanto, podríamos extraer estos polígonos como polígonos correctamente definidos y que no requieren de transformación alguna.\nFinalmente, en caso de que una fila dada sume más de uno implicará que, al menos, contiene un hueco. Por lo que para formar los polígonos con los huecos podemos plantear el procedimiento de la siguiente forma:\nPrimero, para cada fila se puede buscar el polígono de menor tamaño (área) en todo el conjunto de polígonos intersectantes, a partir del cual se construirá un conjunto completamente ordenado según las intersecciones del mismo. Seguidamente, se puede recomponer el conjunto de polígonos como la reordenación en la menor cantidad de conjuntos totalmente ordenados. Tal que de estos conjuntos totalmente ordenados sabremos que el mayor de los conjuntos remite a un polígono lleno, el siguiente a uno hueco, … y así sucesivamente. Para en tercer lugar, conformar mediante operaciones de diferencia y unión los distintos polígonos que den cuenta de los huecos existentes. Plantemiento matemático. Desde un enfoque matemático podemos emplear teoría de conjuntos para evaluar el conjunto de operaciones a realizar para resolver la cuestión. Para ello, lo primero que debemos hacer es establecer las condiciones del problema:\nTenemos un conjunto de $n$ polígonos $p_i$, tal que el conjunto universal de referencia será $\\displaystyle P=\\{p_1, …, p_n\\}$. Tal que estos polígonos son subconjuntos del espacio Euclídeo de dos dimensiones, $p_i\\subset \\mathbb{R}^2$. Existen dos tipos de polígonos: (i) polígonos llenos (o fill) $P_{F}=\\{p_{fi}\\}$ y (ii) polígonos huecos (o holes) $P_H=\\{p_{hi}\\}$, tal que $P=P_F\\cup P_H$. Existe una función $f$ que establece la relación entre un polígono $p_i$ con su área $a_i$, tal que $f:P\\longmapsto A$ es $f(p_i)=a_i$. No obstante, esta función es sólo sobreyectiva si asumimos que puede haber dos o más polígonos con la misma área, mientras que sería sobreyectiva e inyectiva si para cada polígono tiene un área distinta. Si la intersección de dos polígonos es no nula, entonces la intersección resulta en el polígono de menor área. Esto es, $p_i\\cap p_j=\\{\\emptyset\\veebar p_j\\}|f(p_i)\u003ef(p_j)$. Además, tenemos como condición que no existe ningún polígono que intersectando con otro tenga su misma área, $(\\nexists p_i)(p_i,p_j\\in P): f(p_i)=f(p_j)\\iff \\{p_i\\cap p_j\\neq \\emptyset \\wedge i\\neq j\\}$. Para el conjunto de todas las intersecciones no nulas de polígonos $(p_i, p_j)$, tendremos que el conjunto con mayor área es un polígono lleno $f(p_i)\u003ef(p_j):p_i\\in P_F$. Finalmente, como condición debil entre la intersección no nula de dos polígonos llenos, tenemos que existe, al menos, un polígono hueco con mayor área que la del polígono lleno de menor área y que también intersecta con los mismos. Dicho de otro modo, si $p_j\\subset p_i:p_i,p_j\\in P_F\\Rightarrow (\\exists p_k) p_k\\in P_H: p_j\\subset p_k\\subset p_i$. Mientras que la condición fuerte será, que si tenemos dos polígonos tal que uno es subconjunto de otro sin nungún polígono lleno que puede incorporarse como elemento medio entre ambos mediante la operación de subconjunto-de, entonces existe un y sólo un polígono hueco que intermedia entre ambos: $$(\\forall p_i,p_j\\in P_F) p_j\\subset p_i:\\nexists p_k\\in P_F, p_j \\subset p_k \\wedge p_k\\subset p_i \\iff \\exists! p_z\\in P_H: p_j\\subset p_z \\wedge p_z\\subset p_i.$$\rDadas estas condiciones es obvio que puede reordenarse el conjunto $P$ de todos los polígonos, de tal forma que tengamos el menor número de conjuntos completamente ordenados de mayor cardinalidad cuya unión reproduzca el conjunto $P$ de referencia. Es decir, tenemos que conformar todos aquellos conjuntos completamente ordenados $(P_i,\\subset)$, lo cual implica que $(\\forall p_i) p_i\\in P_i (\\exists p_j)p_j\\in P_i\\rightarrow p_j\\subset p_i \\vee p_i\\subset p_j$. Por tanto, debemos construir estos conjuntos completamente ordenados $P_i=\\{p_{i1}\\subset p_{2i}\\subset … \\subset p_{ni}\\}$, de los que sabemos por las condiciones (5) y (6) que para cualquiera de estos conjuntos $P_i$, tendremos que los polígonos llenos serán:\n$$\\{p_{ki},p_{(k-2)i},...,\\}\\in P_F \\Rightarrow p_{(k-2m)i}\\in P_F:m\\in M\\subset\\mathbb{N},$$\rmientras que los polígonos huecos serían: $$\\{p_{(k-1)i},p_{(k-3)i},...,\\}\\in P_H \\Rightarrow p_{(k-1-2m)i}\\in P_H: m\\in M'\\subset\\mathbb{N}.$$\rEl código para poder realizar las transformaciones pertinentes y obtener los polígonos con los huecos correspondientes, es el siguiente:\nsp CompleteOrderedSetsFromSpatialPolygonsClass \u003c- function(SPDINLAnonconvexBoundary){ SPDINLABoundaryList \u003c- list(Polygons=list(), DFIDArea=data.frame(matrix(ncol=2,nrow=0, dimnames=list(NULL, c(\"ID\", \"Area\")))) ) for(i in 1:length(SPDINLAnonconvexBoundary)){ SPDINLABoundaryList$Polygons[[i]] \u003c- SPDINLAnonconvexBoundary[i] SPDINLABoundaryList$DFIDArea[i,] \u003c- c(i, SPDINLAnonconvexBoundary[i]@polygons[[1]]@area) } IndexIDV \u003c- SPDINLABoundaryList$DFIDArea$ID ConnectivityMatrix \u003c- matrix(ncol=length(SPDINLAnonconvexBoundary), nrow=length(SPDINLAnonconvexBoundary)) for(i in 1:length(SPDINLAnonconvexBoundary)){ for(j in i:length(SPDINLAnonconvexBoundary)){ ConnectivityMatrix[i,j] \u003c- ConnectivityMatrix[j,i] \u003c- as.numeric(gIntersects(SPDINLAnonconvexBoundary[i], SPDINLAnonconvexBoundary[j])) } } IndexIsolatedPolygonFill \u003c- which(apply(ConnectivityMatrix, FUN=sum, MARGIN=1)==1) IndexIDV \u003c- if(length(IndexIsolatedPolygonFill)==0){IndexIDV} else{IndexIDV[-which(apply(ConnectivityMatrix, FUN=sum, MARGIN=1)==1)]} CompleteOrderedSets \u003c- list(CompleteOrderedSets=list(), DFCompleteOrderedSets=list(), CompleteOrderedIsolatedSets=list(), DFCompleteOrderedIsolatedSets=list()) if(length(IndexIsolatedPolygonFill)!=0){ for(i in 1:length(IndexIsolatedPolygonFill)){ CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]] \u003c- SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]] CompleteOrderedSets$DFCompleteOrderedIsolatedSets[[i]] \u003c- data.frame(ID=SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]]@polygons[[1]]@ID, Area=SPDINLABoundaryList$Polygons[[IndexIsolatedPolygonFill[i]]]@polygons[[1]]@area, HOLE=FALSE) } } if(length(IndexIsolatedPolygonFill)!=length(IndexIDV)){ n_step \u003c- 1 while(length(IndexIDV)!=0){ IDminArea \u003c- SPDINLABoundaryList$DFIDArea[IndexIDV,\"ID\"][which.min(SPDINLABoundaryList$DFIDArea[IndexIDV,\"Area\"])] IndxCOS \u003c- which(as.logical(ConnectivityMatrix[IDminArea,])) DFIDAreaV \u003c- SPDINLABoundaryList$DFIDArea[IndxCOS,] CompleteOrderedSets$CompleteOrderedSets[[n_step]] \u003c- SpatialPolygons(sapply(DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"ID\"], function(i){ list(SPDINLABoundaryList$Polygons[[i]]@polygons[[1]]) }) ) CompleteOrderedSets$DFCompleteOrderedSets[[n_step]] \u003c- data.frame(ID=DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"ID\"], Area=DFIDAreaV[order(DFIDAreaV$Area, decreasing=TRUE),\"Area\"], HOLE=floor(1:length(IndxCOS)/2)==1:length(IndxCOS)/2 ) IndexIDV \u003c- setdiff(IndexIDV,IndxCOS) n_step \u003c- n_step+1 } SpatialPolygonsNames \u003c- c() for(i in 1:length(CompleteOrderedSets$CompleteOrderedSets)){ if(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2!=floor(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2)){ SpatialPolygonsNames \u003c- c(SpatialPolygonsNames, paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[length(CompleteOrderedSets$CompleteOrderedSets[[i]])])) assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[length(CompleteOrderedSets$CompleteOrderedSets[[i]])]), value=SpatialPolygons(list( CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[length(CompleteOrderedSets$CompleteOrderedSets[[i]])]] ))) } for(j in 1:floor(length(CompleteOrderedSets$CompleteOrderedSets[[i]])/2)){ indx \u003c- 1:2+2*(j-1) if(exists(paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]))){ assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]), value=gDifference(eval(parse(text=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]))), SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[2]]])), id=paste0(CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]) ) ) } else{ SpatialPolygonsNames \u003c- c(SpatialPolygonsNames, paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]])) assign(x=paste0(\"SPDINLA\", CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]), value=gDifference(SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[1]]])), SpatialPolygons(list(CompleteOrderedSets$CompleteOrderedSets[[i]]@polygons[[indx[2]]])), id=paste0(CompleteOrderedSets$DFCompleteOrderedSets[[i]]$ID[indx[1]]) ) ) }} if(length(IndexIsolatedPolygonFill)!=0){ SpatialPolygonRefined \u003c- SpatialPolygons(c(lapply(1:length(SpatialPolygonsNames), function(i){ return(eval(parse(text=paste0(SpatialPolygonsNames[i], \"@polygons[[1]]\")))) }), lapply(1:length(CompleteOrderedSets$CompleteOrderedIsolatedSets), function(i){ return(CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]]@polygons[[1]]) }))) } else{ SpatialPolygonRefined \u003c- SpatialPolygons(lapply(1:length(SpatialPolygonsNames), function(i){ return(eval(parse(text=paste0(SpatialPolygonsNames[i], \"@polygons[[1]]\")))) })) } } } else{ SpatialPolygonRefined \u003c- SpatialPolygons(lapply(1:length(CompleteOrderedSets$CompleteOrderedIsolatedSets), function(i){ return(CompleteOrderedSets$CompleteOrderedIsolatedSets[[i]]@polygons[[1]]) })) } SpatialPolygonRefined@proj4string \u003c- CRS(\"+proj=utm\") CompleteOrderedSetsAndPolygons \u003c- list(CompleteOrderedSets=CompleteOrderedSets, SpatialPolygonRefined=SpatialPolygonRefined) return(CompleteOrderedSetsAndPolygons) } Gracias a esta función tenemos todos los polígonos según las curvas cerradas que los determinan. Esto permite que se puedan realizar operaciones mediante ellos, de tal forma que se esté teniendo en cuenta los huecos existentes.\nPor tanto, siguiendo el ejemplo, tendríamos que aplicar la primera función SpatialPolygonsBoundary sobre el resultado de la malla INLAnonconvexMesh, y posteriormente aplicar la función que acabamos de definir.\nSPDINLAnonconvexBoundary \u003c- SpatialPolygonsBoundary(mesh = INLAnonconvexMesh) PolygonsRefined \u003c- CompleteOrderedSetsFromSpatialPolygonsClass(SPDINLAnonconvexBoundary = SPDINLAnonconvexBoundary) Para que se visualice que propiamente ahora tenemos la totalidad de los polígonos disponibles unos independientes de otros, podemos graficarlos mediante diferentes colores:\ncol \u003c- viridis::turbo(length(PolygonsRefined$SpatialPolygonRefined)) ggplotPolygons \u003c- ggplot() for(i in 1:length(PolygonsRefined$SpatialPolygonRefined)){ ggplotPolygons \u003c- ggplotPolygons + geom_sf(data=st_as_sf(PolygonsRefined$SpatialPolygonRefined[i]), fill=col[i], alpha=0.5) } Tal que, si representamos los polígonos como ggplotPolygons + theme_void() obtendremos la siguiente figura:\nFig. 2: Refined polygons Ejemplo con polígonos apilados. Vamos a presentar un pequeño ejemplo para que se visualice que la función es capaz de extraer un orden arbitrario de polígonos, aunque estos estén apilados. Es decir, en principio, la función aplica para cualquier caso en general que cumpla con dos condiciones, (i) la intersección total y (ii) la ordenación de polígono-lleno / polígono-hueco en niveles sucesivos de intersección máxima interna.\nLo primero que haremos para comprobar que dicha función es capaz de operar con polígonos apilados será crear los polígonos:\nrho1 \u003c- rnorm(120,1,0.01); theta1 \u003c- runif(120,0,2*pi) rho2 \u003c- rnorm(120,6,0.01); theta2 \u003c- runif(120,0,2*pi) rho3 \u003c- rnorm(220,12,0.01); theta3 \u003c- runif(220,0,2*pi) XYPoint \u003c- as.matrix(rbind( cbind(rho1*cos(theta1), rho1*sin(theta1)), cbind(rho2*cos(theta2), rho2*sin(theta2)), cbind(rho3*cos(theta3), rho3*sin(theta3)) )) Boundary \u003c- inla.nonconvex.hull(points=XYPoint, convex=1, resolution=c(100,100)) INLAnonconvexMesh \u003c- inla.mesh.2d(boundary=Boundary, max.edge=1) SPDINLAnonconvexBoundary \u003c- SpatialPolygonsBoundary(mesh=INLAnonconvexMesh) Fig. 3: Nested polygons Fig. 4: Mesh of nested polygons A continuación aplicacamos la función para extraer los polígonos con los huecos y representamos gráficamente el resultado:\nPolygonsRefined \u003c- CompleteOrderedSetsFromSpatialPolygonsClass(SPDINLAnonconvexBoundary=SPDINLAnonconvexBoundary) col \u003c- viridis::turbo(length(PolygonsRefined$SpatialPolygonRefined)) ggplotPolygons \u003c- ggplot() for(i in 1:length(PolygonsRefined$SpatialPolygonRefined)){ ggplotPolygons \u003c- ggplotPolygons + geom_sf(data=st_as_sf(PolygonsRefined$SpatialPolygonRefined[i]), fill=col[i], alpha=0.5) } Fig. 5: Nested polygons fixing holes ",
    "description": "Aquí definimos algunas funciones relativas a la transformación de un objeto inla.mesh a un objeto sp/sf.",
    "tags": null,
    "title": "Transformación a sp/sf",
    "uri": "/es/inla/variousfunctions/inlatosp/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/es/categories/index.html"
  },
  {
    "content": "Aquí se expondran distintas funciones que se han ido desarrollando para su implementación en procesos automatizados o que puedan resultar de interés.\nTransformación a sp/sfAquí definimos algunas funciones relativas a la transformación de un objeto inla.mesh a un objeto sp/sf.\n",
    "description": "List the child pages of a page",
    "tags": null,
    "title": "Funciones Varias",
    "uri": "/es/inla/variousfunctions/index.html"
  },
  {
    "content": "En esta sección expondremos\n",
    "description": "Un modelo geoestadístico simple en INLA.",
    "tags": null,
    "title": "Modelo Geoestadístico",
    "uri": "/es/inla/spatialmodels/geostatisticalmodel/index.html"
  },
  {
    "content": "In this section we will show\n",
    "description": "Un modelo conjunto para datos prefenciales.",
    "tags": null,
    "title": "Modelo Preferencial",
    "uri": "/es/inla/spatialmodels/jointmodel_preferential/index.html"
  },
  {
    "content": "En esta sección expondremos cómo realizar distintos tipos de modelos espaciales con INLA en el entonrno R-INLA:\n",
    "description": "Modelos de Coeficientes Espacialmente Variables.",
    "tags": null,
    "title": "Modelo SVC",
    "uri": "/es/inla/spatialmodels/spatialvaryingcoefficientmodel/index.html"
  },
  {
    "content": "En esta sección expondremos cómo realizar distintos tipos de modelos espaciales con INLA en el entonrno R-INLA:\nModelo GeoestadísticoUn modelo geoestadístico simple en INLA.\nModelo PreferencialUn modelo conjunto para datos prefenciales.\nModelo SVCModelos de Coeficientes Espacialmente Variables.\n",
    "description": "Sección para los Modelos Espaciales.",
    "tags": null,
    "title": "Modelos Espaciales",
    "uri": "/es/inla/spatialmodels/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/es/tags/index.html"
  }
]
