<!DOCTYPE html>
<html lang="es" dir="ltr">
  <head>
    
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="description" content="Documentation for Bayesian Statistics">
    <meta name="author" content="Mario Figueira">
    <title>INLA :: Documentación</title>
    <link href="https://MarioFigueiraP.github.io/es/inla/index.html" rel="canonical" type="text/html" title="INLA :: Documentación">
    <link href="../../es/inla/index.xml" rel="alternate" type="application/rss+xml" title="INLA :: Documentación">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../css/fontawesome-all.min.css" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/fontawesome-all.min.css" rel="stylesheet"></noscript>
    <link href="../../css/featherlight.min.css" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/featherlight.min.css" rel="stylesheet"></noscript>
    <link href="../../css/auto-complete.css" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/auto-complete.css" rel="stylesheet"></noscript>
    <link href="../../css/perfect-scrollbar.min.css" rel="stylesheet">
    <link href="../../css/nucleus.css" rel="stylesheet">
    <link href="../../css/fonts.css" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/fonts.css" rel="stylesheet"></noscript>
    <link href="../../css/theme.css" rel="stylesheet">
    <link href="../../css/theme-learn.css" rel="stylesheet" id="variant-style">
    <link href="../../css/ie.css" rel="stylesheet">
    <link href="../../css/variant.css" rel="stylesheet">
    <link href="../../css/print.css" rel="stylesheet" media="print">
    <link href="../../css/format-print.css" rel="stylesheet">
    <script src="../../js/url.js"></script>
    <script src="../../js/variant.js"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../es/index.search.js";
      var root_url="../../";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copiar en el portapapeles';
      window.T_Copied_to_clipboard = '¡Copiado al portapapeles!';
      window.T_Copy_link_to_clipboard = 'Copiar enlace al portapapeles';
      window.T_Link_copied_to_clipboard = '¡Enlace copiado al portapapeles!';
      window.T_No_results_found = 'No se han encontrado resultados para \u0022{0}\u0022';
      window.T_N_results_found = '{1} resultados encontrados para \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/MarioFigueiraP.github.io/';
      window.variants && variants.init( [ 'learn', 'relearn-light', 'relearn-dark', 'neon', 'blue', 'green', 'red' ] );
    </script>
    <script src="../../js/jquery.min.js" defer></script>
  </head>
  <body class="mobile-support print" data-url="../../es/inla/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable" dir="ltr">
        <div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menú (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../es/index.html"><span itemprop="name">Inicio</span></a><meta itemprop="position" content="1"> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">INLA</span><meta itemprop="position" content="2"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
          <article class="chapter deprecated">

<h1 id="metodología-inla">Metodología INLA</h1>
<p>Existen distintas metodologías para la realización computacional de inferencia bayesiana, métodos de simulación como MCMC (Markov chain Monte Carlo) o métodos aproximativos como VB (variational Bayes); todas ellas con sus dificultades propias. No obstante, <strong>INLA</strong> (Integrated Nested Laplace Approximation) es un enfoque determinista aproximado, desarrollado por <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/j.1467-9868.2008.00700.x">(Rue, Martino y Chopin, 2009)</a> y ampliado en <a href="https://www.jstatsoft.org/article/view/v063i19">(Lindgren y Rue, 2015</a>; <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2937741">Rue y col., 2017</a>; <a href="https://wires.onlinelibrary.wiley.com/doi/abs/10.1002/wics.1443">Bakka y col., 2018)</a>, que permite realizar la inferencia Bayesiana en un conjunto de modelos aditivos estructurados, denominados <em>modelos Gaussianos latentes</em> (LGMs). El método de <strong>INLA</strong> permite el cálculo de las dsitribuciones posteriores conjuntas, las distribuciones marginales de cada parámetro e hiperparámetro, así como combinaciones de estos o las distribuciones predictivas posteriores.</p>
<p>El núcleo de <strong>INLA</strong> es la <em>aproximación de Laplace</em> aplicada a la expresión de la distribución de probabilidad condicional del <em>campo latente</em>. Esto implica que la estructura latente debe ser la de un <em>campo Gaussiano Markoviano aleatorio</em> (GMRF) que puede ligarse a <em>modelos Gaussianos latentes</em> <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/j.1467-9868.2011.00777.x">(Lindgren, Rue y Lindström)</a>. Aunque muchos modelos pueden ser re-escritos de tal modo que su estructura sea sigmilar a la de un LGM.</p>
<h2 id="aproximación-de-laplace">Aproximación de Laplace</h2>
<p>La aproximación de Laplace para una función de densidad  
<span class="math align-center">$f(x)$</span> supone la transformación mediante logaritmos y la realización de un desarrollo en serie de Taylor de segundo orden, evaluado en la moda de la función:</p>

<span class="math align-center">
$$ \begin{array}{r l}
\int_X f(x)dx& =\int_X\exp[\log(f(x))]dx\\ &\approx \int_X \exp\left( \log(f(x_0)) + (x-x_0)\left.\frac{\partial \log(f(x))}{\partial x}\right\vert_{x=x_0} + \frac{(x-x_0)^2}{2}\left.\frac{\partial^2 \log(f(x))}{\partial x}^2\right\vert_{x=x_0}\right)dx,
\end{array}
$$
</span>
<p>donde la función 
<span class="math align-center">$f(x)$</span> será evaluada en la moda, 
<span class="math align-center">$\left.f(x)\right\vert_{x=x_0}$</span>, tal que</p>

<span class="math align-center">$$x_0=\{x:\frac{\partial f(x)}{\partial x}=0 \wedge \frac{\partial^2 f(x)}{\partial x^2} \neq 0 \}.$$</span>
<p>Esto es, la función queda evaluada cuando la primera derivada es nula, por lo que el término del desarrollo en serie de Taylor de primer orden puede ser simplificado. Además, si expresamos el término de segundo orden como</p>

<span class="math align-center">$$\sigma^2=\left.\frac{1}{\partial^2 \log(f(x))/\partial x^2}\right\vert_{x=x_0},$$</span>
<p>entonces podemos expresar la aproximación de Laplace como  el kernel de una función Gaussiana:</p>

<span class="math align-center">$$\int_Xf(x)dx\approx f(x_0)\cdot \int_X \exp\left(-\frac{(x-x_0)^2}{2\sigma^2}\right)dx.$$</span>
<h2 id="campo-gaussiano-markoviano-aleatorio">Campo Gaussiano Markoviano Aleatorio</h2>
<p>Un <em>campo Gaussiano Markoviano aleatorio</em> (GMRF) es un <em>campo Gaussiano</em> (GF) con propiedades de Markov. Es decir, dado un vector aleatorio 
<span class="math align-center">$\mathbf{x}\in \mathbb{R}^n$</span> se dice GMRF con referencia a un grafo  
<span class="math align-center">$\mathcal{G}=(\mathcal{V}, \mathcal{E})$</span> con media 
<span class="math align-center">$\boldsymbol\mu$</span> y matriz de precisión (simétrica definida positiva) 
<span class="math align-center">$\mathbf{Q}>0$</span> si su densidad tiene la siguiente estructura</p>

<span class="math align-center">$$\pi(\mathbf{x})=(2\pi)^{-n/2}|\mathbf{Q}|^{1/2}\exp\left(-\frac{1}{2}(\mathbf{x}-\boldsymbol\mu)^T\mathbf{Q}(\mathbf{x}-\boldsymbol\mu)\right),$$</span>
<p>y</p>

<span class="math align-center">$$(\forall i\neq j) \left\lbrace Q_{ij}\neq 0 \iff \{i,j\}\in \mathcal{E}\right\rbrace.$$</span>
<p>Si la matriz de precisión 
<span class="math align-center">$\mathbf{Q}$</span> es completamente densa entonces el grafo 
<span class="math align-center">$\mathcal{G}$</span> está completamente conectado. Esto implica que cualquier distribución normal con matriz de covarianzas <i> simétrica definida positiva</i> (SPD) es un GMRF y vice versa.</p>
<p>En el caso en el que 
<span class="math align-center">$\mathbf{Q}$</span> es dispersa entonces las propiedades de los GMRFs son realmente útiles y podremos hacer uso de ellas. En particular, una propiedades de gran utilidad es la intepretación de las distribuciones condicionales de los elementos de un GMRF.</p>
<p>Supongamos que 
<span class="math align-center">$\mathbf{x}$</span> es un GMRF con respecto a un grafo 
<span class="math align-center">$\mathcal{G}=(\mathcal{V}, \mathcal{E})$</span>, con media 
<span class="math align-center">$\boldsymbol\mu$</span> y matriz de precisión (simétrica definida positiva) 
<span class="math align-center">$\mathbf{Q}>0$</span>, entonces</p>

<span class="math align-center">$$\begin{array}{rcl}
\text{E}(x_i|\mathbf{x}_{-i}) & = & \mu_i - \frac{1}{Q_{ii}}\sum_{j:j\sim i}Q_{ij}(x_j-\mu_j),\\
\text{Prec}(x_i|\mathbf{x}_{-i}) & = & Q_{ii},\\
\text{Corr}(x_i,x_j|\mathbf{x}_{-ij}) & = & -\frac{Q_{ij}}{\sqrt{Q_{ii}Q_{jj}}},\quad  i\neq j.\\
\end{array}
$$</span>
<p>Los elementos diagonales de 
<span class="math align-center">$\mathbf{Q}$</span> son las precisiones condicionales de 
<span class="math align-center">$x_i$</span> dado 
<span class="math align-center">$\mathbf{x}_{-i}$</span>, mientras que los elementos fuera de la diagonal, con un escalado, son la correlación condicional entre 
<span class="math align-center">$x_i$</span> y 
<span class="math align-center">$x_j$</span>, dados 
<span class="math align-center">$\mathbf{x}_{-ij}$</span>.</p>
<h2 id="campos-gaussianos-latentes">Campos Gaussianos latentes</h2>
<p>La estructura en la que se basa <strong>INLA</strong> puede sintetizarse en el siguiente modelo jerárquico:</p>

<span class="math align-center">$$\begin{array}{rcl}
\mathbf{y}|\mathbf{\mathcal{X}},\boldsymbol\theta_1 & \sim & \prod_{i=1}^{n}\pi(y_i|\mathcal{X}_i,\boldsymbol\theta_1),\\
\mathbf{\mathcal{X}}|\boldsymbol\theta_2 & \sim & N(\mathbf{0},\mathbf{Q}_{\mathbf{\mathcal{X}}}^{-1}(\boldsymbol\theta_2)),\\
\boldsymbol\theta=\{\boldsymbol\theta_1,\boldsymbol\theta_2\} & \sim & \pi(\boldsymbol\theta),\\
\end{array}
$$</span>
<p>donde 
<span class="math align-center">$\mathbf{y}|\mathbf{\mathcal{X}},\boldsymbol\theta_1$</span> es la parte relativa a los datos (o verosimilitud), siendo 
<span class="math align-center">$\mathbf{\mathcal{X}}$</span> los elementos del campo latente y 
<span class="math align-center">$\boldsymbol\theta_1$</span> los hiperparámetros de la verosimilitud. Los elementos del campo latente se distribuyen según 
<span class="math align-center">$\mathbf{\mathcal{X}}|\boldsymbol\theta_2$</span>, siguiendo un GMRF de media 
<span class="math align-center">$\mathbf{0}$</span> y la estructura del campo latente queda integrada en la estructura de la matriz de precisión 
<span class="math align-center">$\mathbf{Q}_{\mathbf{\mathcal{X}}}^{-1}(\boldsymbol\theta_2)$</span>, donde 
<span class="math align-center">$\boldsymbol\theta_2$</span> son los hiperparámetros del campo latente. Finalmente, el último nivel es el relativo a la distribución de los hiperparámetros del modelo 
<span class="math align-center">$(\boldsymbol\theta)$</span>, comprendiendo tanto a los de la verosimilitud 
<span class="math align-center">$(\boldsymbol\theta_1)$</span> como los relativos al campo latente 
<span class="math align-center">$(\boldsymbol\theta_2)$</span>.</p>
<p>El segundo nivel es el <em>campo Gaussiano latente</em>, que constituye un <em>modelo Gaussiano latente</em> (LGM). Los LGMs son una clase de modelos que siguen procesos Gaussianos, sea tanto para series temporales, modelos espaciales, efectos aleatorios <em>iid</em>, efectos aleatorios cluster, etc. Por tanto, el campo Gaussiano que tiene la anterior estructura puede también formularse según el predictor lineal del modelo como</p>

<span class="math align-center">$$\begin{array}{c}
\boldsymbol\eta=\beta_0\mathbf{1} + \boldsymbol\beta\mathbf{X} + \sum_{k=1}^K f_k(\mathbf{u}_k),
\end{array}
$$</span>
<p>donde 
<span class="math align-center">$(\beta_0, \boldsymbol\beta)$</span> son los parámetros asociados a los efectos lineales, mientras que 
<span class="math align-center">$\{\mathbf{f}\}$</span> son funciones desconocidas de los efectos aleatorios 
<span class="math align-center">$\mathbf{U}=\{\mathbf{u}\}$</span>, pudiendo tener estructuras muy variadas: <em>iid</em>, <em>random walk</em>, <em>Besag</em>, <em>SPDE</em> (<em>stochastic partial differential equation</em>), etc.</p>
<p>Partiendo de la anterior expresión, podemos reformularla en términos matriciales 
<span class="math align-center">$\boldsymbol\eta=\mathbf{A}_j\mathbf{u}_j$</span>, donde se ligan los efectos 
<span class="math align-center">$(\mathbf{u}_j)$</span> con el predictor de las observaciones 
<span class="math align-center">$(\boldsymbol\eta)$</span> a través de una matriz de proyección 
<span class="math align-center">$(\mathbf{A}_j)$</span> relativa a cada efecto 
<span class="math align-center">$(\mathbf{u}_j)$</span>. Esta matriz de proyección incorpora los pesos asociadas a los efectos, por ejemplo los valores de las variables explicativas para los efectos lineales, pesos asociados a estructuras de suavizado o pesos asociados a SPDEs. Es decir, podemos re-escribirlo como</p>

<span class="math align-center">$$
\boldsymbol\eta=\left(
\begin{array}{c}
\eta_1\\ \hline
\vdots \\ \hline 
\eta_K
\end{array}\right)=\left(\mathbf{A}_1| \mathbf{A}_2| \cdots | \mathbf{A}_J\right) 
\left(
\begin{array}{c}
\mathbf{u}_1\\ \hline
\mathbf{u}_2 \\ \hline
\vdots \\ \hline 
\mathbf{u}_J
\end{array}\right),
$$</span>
<p>donde cada efecto 
<span class="math align-center">$\mathbf{u}_j:j\in (1,...,J)$</span> está ligado a su correspondiente matriz de proyección 
<span class="math align-center">$\mathbf{A}_j$</span>, conectando los efectos con el predictor lineal 
<span class="math align-center">$\boldsymbol\eta=(\eta_1,...,\eta_K)$</span>.</p>
<h2 id="artículos-fundamentales">Artículos Fundamentales</h2>
<ol>
<li>
<div class="csl-entry">Bakka, H., Rue, H., Fuglstad, G.-A., Riebler, A. I., Bolin, D., Illian, J., Krainski, E., Simpson, D. P., &#38; Lindgren, F. K. (2018). Spatial modelling with INLA: A review. In <i>Wires</i> (Vol. xx, Issue Feb). <a href="https://doi.org/10.1002/wics.1443">https://doi.org/10.1002/wics.1443</a></div>
</li>
<li>
<div class="csl-entry">Lindgren, F., Rue, H., &#38; Lindström, J. (2011). An explicit link between gaussian fields and gaussian markov random fields: The stochastic partial differential equation approach. <i>Journal of the Royal Statistical Society. Series B: Statistical Methodology</i>, <i>73</i>(4). <a href="https://doi.org/10.1111/j.1467-9868.2011.00777.x">https://doi.org/10.1111/j.1467-9868.2011.00777.x</a></div>
</li>
<li>
<div class="csl-entry">Lindgren, F., &#38; Rue, H. (2015). Bayesian spatial modelling with R-INLA. <i>Journal of Statistical Software</i>, <i>63</i>(19). <a href="https://doi.org/10.18637/jss.v063.i19">https://doi.org/10.18637/jss.v063.i19</a></div>
</li>
<li>
<div class="csl-entry">Rue, H., Martino, S., &#38; Chopin, N. (2009). Approximate Bayesian inference for latent Gaussian models by using integrated nested Laplace approximations. <i>Journal of the Royal Statistical Society. Series B: Statistical Methodology</i>, <i>71</i>(2). <a href="https://doi.org/10.1111/j.1467-9868.2008.00700.x">https://doi.org/10.1111/j.1467-9868.2008.00700.x</a></div>
</li>
<li>
<div class="csl-entry">Rue, H., Riebler, A., Sørbye, S., Illian, J., Simpson, D. &#38; Lindgren, F. (2017). Bayesian Computing with INLA: A Review. <i>Annual Review of Statistics and Its Application</i>, <i>4:1, 395-421</i>. <a href="https://doi.org/10.1146/annurev-statistics-060116-054045">https://doi.org/10.1146/annurev-statistics-060116-054045</a></div>
</li>
</ol>
<h2 id="libros">Libros</h2>
<ol>
<li>
<div class="csl-entry">Blangiardo, M., &#38; Cameletti, M. (2015). Spatial and Spatio-temporal Bayesian Models with R - INLA. In <i>Spatial and Spatio-temporal Bayesian Models with R - INLA</i>. Wiley. <a href="https://doi.org/10.1002/9781118950203">https://doi.org/10.1002/9781118950203</a></div>
</li>
<li>
<div class="csl-entry">Gómez-Rubio, V. (2020). Bayesian Inference with INLA. In <i>Bayesian Inference with INLA</i>. Chapman &#38; Hall/CRC Press. <a href="https://doi.org/10.1201/9781315175584">https://doi.org/10.1201/9781315175584</a></div>
</li>
<li>
<div class="csl-entry">Moraga, P. (2019). <i>Geospatial Health Data</i>. Chapman and Hall/CRC. <a href="https://doi.org/10.1201/9780429341823">https://doi.org/10.1201/9780429341823</a></div>
</li>
<li>
<div class="csl-entry">Krainski, E., Gómez-Rubio, V., Bakka, H., Lenzi, A., Castro-Camilo, D., Simpson, D., Lindgren, F., &#38; Rue, H. (2018). Advanced Spatial Modeling with Stochastic Partial Differential Equations Using R and INLA. In <i>Advanced Spatial Modeling with Stochastic Partial Differential Equations Using R and INLA</i>. <a href="https://doi.org/10.1201/9780429031892">https://doi.org/10.1201/9780429031892</a></div>
</li>
<li>
<div class="csl-entry">Rue, H., &#38; Held, L. (2005). <i>Gaussian Markov Random Fields</i>. Chapman and Hall/CRC. <a href="https://doi.org/10.1201/9780203492024">https://doi.org/10.1201/9780203492024</a></div>
</li>
<li>
<div class="csl-entry">Xiaofeng Wang, Ryan Yue, &#38; Faraway, J. J. (2018). <i>Bayesian Regression Modeling with INLA</i>. Chapman &#38; Hall.</div>
</li>
</ol>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsecciones de INLA</h1>
          <article class="default">
<h1 id="operaciones-b%C3%A1sicas">Operaciones Básicas</h1>

<p>En este apartado expondremos distintas funciones y operaciones básicas, que son fundamentales para la modelización con INLA.</p>

<ul class="children children-li children-sort-weight">
	
<li><a href="../../es/inla/basicoperationalinfo/linearmodels/index.html">Modelos Lineales Simples</a><p>Ejemplos simples de modelos lineales y evaluación de la salida de la función ``inla(...)``.</p></li>
<li><a href="../../es/inla/basicoperationalinfo/stacks/index.html">Stacks</a><p>Breve introducción y ejemplificación de la organización de información en Stacks.</p></li>
<li><a href="../../es/inla/basicoperationalinfo/meshes/index.html">Conformación de Mallas</a><p>Breve introducción a la conformación de mallas.</p></li>
<li><a href="../../es/inla/basicoperationalinfo/advanced_features/index.html">Características Avanzadas</a><p>Introducción a características avanzadas de INLA y sus usos.</p></li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsecciones de Operaciones Básicas</h1>
          <article class="default">
<h1 id="modelos-lineales-simples">Modelos Lineales Simples</h1>


<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info"></i> Información de versiones</div>
    <div class="box-content">
<p>En este rótulo inicial exponemos una lista con las versiones de los programas, sistema operativo y librearías con las que se ha ejecutado el código de la presente sección, lo cual se extrae principalmente mediante la función <code>sessionInfo()</code>.</p>
<ul>
<li>SO (version): Windows 11 Home (22H2).</li>
<li>R: 4.2.3 (2023-03-15 ucrt).</li>
<li>RStudio: 2023.06.2 (Build 561).</li>
<li>Libraries:
<ul>
<li>INLA: INLA_23.04.24</li>
</ul>
</li>
</ul>
    </div>
</div>
<p>En esta sección se expondrán distintos ejemplos de modelos sencillos con datos simulados, para así mostrar cómo operar con <strong>R-INLA</strong>. A lo largo de los ejemplos se comentará el código empleado y se tratará de explicar el funcionamiento de las funciones empleadas relativas al paquete <strong>R-INLA</strong>, junto con las salidas de la función de ajuste <code>inla(...)</code>.</p>
<p>Los ejemplos sobre los que trabajaremos son los siguientes:</p>
<ol>
<li>Modelo Gaussiano con interceptor y efecto lineal.</li>
<li>Modelo Gaussiano con factores.</li>
<li>Modelo Gaussiano con efectos aleatorios.
<ol>
<li>Efectos aleatorios no-estructurados (<em>iid</em>)</li>
<li>Efectos aleatorios estructurados en una dimensión (<em>rw</em>, <em>ar</em> y <em>spde</em>)</li>
<li>Efectos aleatorios estructurados en dos dimensiones (<em>besag</em> y <em>spde</em>)</li>
</ol>
</li>
</ol>
<h2 id="1-modelo-gaussiano-con-un-interceptor-y-un-efecto-lineal">1. Modelo Gaussiano con un interceptor y un efecto lineal</h2>
<p>Un ejemplo de modelo Gaussiano sencillo puede ser aquel cuyo predictor lineal esté determinado por un interceptor y un efecto fijo asociado a una variable continua. Es decir, el modelo formalmente es expresable como</p>

<span class="math align-center">
$$\begin{array}{c}
y_i\sim N(\mu_i,\tau),\\
\mu_i = \eta_i = \beta_0 + \beta_1\cdot x_i,
\end{array}$$
</span>
<p>donde 
<span class="math align-center">$y_i$</span> son las realizaciones de la variable aleatoria respuesta 
<span class="math align-center">$Y:Y\sim N(\boldsymbol\mu,\tau)$</span>, 
<span class="math align-center">$\beta_0$</span> es el interceptor, 
<span class="math align-center">$\beta_1$</span> es el parámetro realativo al efecto de la variable explicativa 
<span class="math align-center">$\mathbf{x}$</span>, y 
<span class="math align-center">$x_i$</span> son los valores de la variable explicativa. El código que podríamos utilizar para simular este modelo es el presentado en el siguiente bloque de código.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="m">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">beta_0</span> <span class="o">&lt;-</span> <span class="m">-2</span>
</span></span><span class="line"><span class="cl"><span class="n">beta_1</span> <span class="o">&lt;-</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl"><span class="n">lin_pred</span> <span class="o">&lt;-</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="n">beta_1</span><span class="o">*</span><span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">lin_pred</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">3</span><span class="p">)</span>
</span></span></code></pre></div><p>Antes de organizar la información de los datos podemos especificar la fórmula del modelo,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">formula_inla</span> <span class="o">&lt;-</span> <span class="n">y</span> <span class="o">~</span> <span class="m">-1</span> <span class="o">+</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="n">beta_1</span>
</span></span></code></pre></div><p>donde <code>y</code> es el nombre de la variable respuesta, el término <code>-1</code> elimina el interceptor que se construye por defecto, mientras que <code>beta_0</code> y <code>beta_1</code> son dos parámetros o variables fijas, a las que en el <code>data.frame</code> o la matriz de proyección <code>A</code> se pasarán los pesos asociados a los mismos. En el caso de un interceptor estos pesos sería un vector de unos, mientras que los pesos de los parámetros relativos a las variables explicativas tendrán por pesos los valores de dichas variables.</p>
<p>En la propia fórmula podemos indicar la distribución previa de los parámetros, en concreto para el caso de los efectos lineales lo haríamos como</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">formula_inla</span> <span class="o">&lt;-</span> <span class="n">y</span> <span class="o">~</span> <span class="m">-1</span> <span class="o">+</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">f</span><span class="p">(</span><span class="n">beta_0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s">&#34;linear&#34;</span><span class="p">,</span> <span class="n">mean.linear</span><span class="o">=</span><span class="m">0</span><span class="p">,</span> <span class="n">prec.linear</span><span class="o">=</span><span class="m">0.001</span><span class="p">)</span> <span class="o">+</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">f</span><span class="p">(</span><span class="n">beta_1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s">&#34;linear&#34;</span><span class="p">,</span> <span class="n">mean.linear</span><span class="o">=</span><span class="m">0</span><span class="p">,</span> <span class="n">prec.linear</span><span class="o">=</span><span class="m">0.001</span><span class="p">)</span>
</span></span></code></pre></div><p>La información podemos prepararla mediante la función <code>inla.stack(...)</code> para pasarla a la función de ajuste <code>inla(...)</code>, (véase la <a href="https://mariofigueirap.github.io/es/inla/basicoperationalinfo/stacks/index.html">sección dedicada a los <em>stacks</em></a> para más información).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span>
</span></span><span class="line"><span class="cl">    <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                <span class="n">beta_1</span><span class="o">=</span><span class="n">x</span>
</span></span><span class="line"><span class="cl">            <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span></code></pre></div><p>El ajuste del modelo lo realizamos mediante <code>inla(...)</code>, donde indicamos la fórmula, la distribución de la verosimilitud, los datos necesarios para el modelo (que podemos extraer del <em>stack</em> mediante <code>inla.stack.data(...)</code>), y otros elementos de configuración que podemos especificar.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inla_model</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">inla</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">formula</span><span class="o">=</span><span class="n">formula_inla</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nf">inla.stack.data</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">),</span> <span class="n">family</span><span class="o">=</span><span class="s">&#34;gaussian&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">control.predictor</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="nf">inla.stack.A</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">),</span> <span class="n">compute</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">control.compute</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">waic</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span> <span class="n">cpo</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span> <span class="n">dic</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">verbose</span><span class="o">=</span><span class="kc">TRUE</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span></code></pre></div><p>En la función <code>inla(...)</code> hemos especificado la fórmula, la distribución de los datos, la matriz de proyección, y además con <code>control.predictor(compute=TRUE)</code> indicamos que se calculen las distribuciones marginales del predictor lineal (para almacenarlas se necesitaría especificar con un argumento extra <code>return.marginals.predictor=TRUE</code>). Con <code>control.compute(waic=TRUE, cpo=TRUE, dic=TRUE, config=TRUE)</code> indicamos que se calcule el WAIC, CPO, DIC, y que la aproximación GMRF interna se almacene.</p>
<p>La salida de la función, guardada en el objeto <code>inla_model</code> según el código empleado, tendremos ciertos sumarios (<em>summaries</em>) de información sobre el ajuste:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Argumento</th>
<th style="text-align:left">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">summary.fixed</td>
<td style="text-align:left">Resumen de información de las distribuciones posteriores de los efectos fijos.</td>
</tr>
<tr>
<td style="text-align:center">summary.hyperpar</td>
<td style="text-align:left">Resumen de las distribuciones posteriores de los hiper-parámetros (parámetros asociados a la estructura de los efectos aleatorios y de los hiperparámetros de la verosimilitud).</td>
</tr>
<tr>
<td style="text-align:center">summary.random</td>
<td style="text-align:left">Resumen de las distribuciones posteriores para cada uno de los elementos (nodos) de los efectos aleatorios.</td>
</tr>
<tr>
<td style="text-align:center">summary.linear.predictor</td>
<td style="text-align:left">Resumen de las distribuciones posteriores del predictor lineal y el campo latente. Esto se divide en dos partes, una nombrada bajo la siguiente estructura: <code>fitted.APredictor.n</code>, donde <code>n</code> es un valor numérico relativo a la posición asociada a la observación <code>y_n</code>, y <code>fitted.Predictor.m</code>, donde <code>m</code> es un valor numérico relativo a la posición asociada al elemento <code>x_m</code> del campo Gaussiano latente. Es decir, la primera es tras aplicar la matriz de proyección <code>A</code> sobre las observaciones, mientras que la segunda es la relativa al campo latente en sentido estricto. Esto puede volverse algo más complejo al emplear múltiples <em>stacks</em> y múltiples verosimilitudes.</td>
</tr>
</tbody>
</table>
<p>Otros elementos muy útiles de la salida del modelo son las distribuciones marginales, tanto de los parámetros e hiperparámetros, así como de los efectos aleatorios y el predictor lineal.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Argumento</th>
<th style="text-align:left">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">marginals.fixed</td>
<td style="text-align:left">Distribuciones posteriores de los efectos fijos.</td>
</tr>
<tr>
<td style="text-align:center">marginals.hyperpar</td>
<td style="text-align:left">Distribuciones posteriores de los hiper-parámetros (parámetros asociados a la estructura de los efectos aleatorios y de los hiperparámetros de la verosimilitud).</td>
</tr>
<tr>
<td style="text-align:center">marginals.random</td>
<td style="text-align:left">Distribuciones posteriores para cada uno de los elementos (nodos) de los efectos aleatorios.</td>
</tr>
<tr>
<td style="text-align:center">marginals.linear.predictor</td>
<td style="text-align:left">Distribuciones posteriores del predictor lineal y el campo latente. Esto se divide en dos partes, una nombrada bajo la siguiente estructura: <code>fitted.APredictor.n</code> y <code>fitted.Predictor.m</code>, al igual que habíamos explicado para el resumen de las mismas.</td>
</tr>
</tbody>
</table>
<p>Finalmente, otros elementos de gran interés en la salida del modelo son los valores del DIC, WAIC, CPO y la verosimilitud marginal (<code>mlik</code>).</p>
<table>
<thead>
<tr>
<th style="text-align:center">Argumento</th>
<th style="text-align:left">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">marginals.fixed</td>
<td style="text-align:left">Distribuciones posteriores de los efectos fijos.</td>
</tr>
<tr>
<td style="text-align:center">marginals.hyperpar</td>
<td style="text-align:left">Distribuciones posteriores de los hiper-parámetros (parámetros asociados a la estructura de los efectos aleatorios y de los hiperparámetros de la verosimilitud).</td>
</tr>
<tr>
<td style="text-align:center">marginals.random</td>
<td style="text-align:left">Distribuciones posteriores para cada uno de los elementos (nodos) de los efectos aleatorios.</td>
</tr>
<tr>
<td style="text-align:center">mlik</td>
<td style="text-align:left">Verosimilitud marginal para la distintas verosimilitudes.</td>
</tr>
</tbody>
</table>
<h2 id="2-modelo-gaussiano-con-factores">2. Modelo Gaussiano con factores</h2>
<p>En este caso vamos a exponer como se pueden tratar de analizar datos con variables explicativas que son factores con INLA. El modelo del que simularemos los datos es el siguiente</p>

<span class="math align-center">
$$\begin{array}{c}
y_i\sim N(\mu_i,\tau),\\
\mu_i = \eta_i = \beta_0 + \sum_{f=1}^{F}\beta_{f} \cdot x_{if},
\end{array}$$
</span>
<p>donde 
<span class="math align-center">$\beta_0$</span> es el interceptor, 
<span class="math align-center">$\beta_f$</span> es el parámetro realativo al efecto de la variable explicativa 
<span class="math align-center">$\mathbf{X}$</span>. En este caso 
<span class="math align-center">$\mathbf{X}$</span> es una variable de tipo factor que, en general, tiene 
<span class="math align-center">$f=\{1,...,F\}$</span> niveles, tal que 
<span class="math align-center">$(\forall i) (\exists! f) : \left\lbrace x_{if}=1 \wedge x_{i,-f}=\mathbf{0}\right\rbrace$</span>. Por tanto, para cada observación sólo uno de estos niveles tiene asociado un valor . El código que podríamos utilizar para simular este modelo es el presentado en el siguiente bloque de código.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="m">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">beta_0</span> <span class="o">&lt;-</span> <span class="m">-2</span>
</span></span><span class="line"><span class="cl"><span class="n">beta_1</span> <span class="o">&lt;-</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl"><span class="n">lin_pred</span> <span class="o">&lt;-</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="n">beta_1</span><span class="o">*</span><span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">lin_pred</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">3</span><span class="p">)</span>
</span></span></code></pre></div><p>Antes de organizar la información de los datos podemos especificar la fórmula del modelo,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">formula_inla</span> <span class="o">&lt;-</span> <span class="n">y</span> <span class="o">~</span> <span class="m">-1</span> <span class="o">+</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="n">beta_1</span>
</span></span></code></pre></div><h2 id="3-modelo-gaussiano-con-efectos-aleatorios">3. Modelo Gaussiano con efectos aleatorios</h2>
<h3 id="31-efectos-aleatorios-no-estructurados-iid">3.1 Efectos aleatorios no-estructurados (<em>iid</em>)</h3>
<h3 id="32-efectos-aleatorios-estructurados-en-una-dimensión-rw-ar-y-spde">3.2 Efectos aleatorios estructurados en una dimensión (<em>rw</em>, <em>ar</em> y <em>spde</em>)</h3>
<h3 id="33-efectos-aleatorios-estructurados-en-dos-dimensiones-besag-y-spde">3.3 Efectos aleatorios estructurados en dos dimensiones (<em>besag</em> y <em>spde</em>)</h3>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
<h1 id="stacks">Stacks</h1>


<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info"></i> Información de versiones</div>
    <div class="box-content">
<p>En este rótulo inicial exponemos una lista con las versiones de los programas, sistema operativo y librearías con las que se ha ejecutado el código de la presente sección, lo cual se extrae principalmente mediante la función <code>sessionInfo()</code>.</p>
<ul>
<li>SO (version): Windows 11 Home (22H2).</li>
<li>R: 4.2.3 (2023-03-15 ucrt).</li>
<li>RStudio: 2023.06.2 (Build 561).</li>
<li>Libraries:
<ul>
<li>INLA: INLA_23.04.24</li>
</ul>
</li>
</ul>
    </div>
</div>
<p>Los <code>stack</code> son unas funciones implementadas en el paquete <strong>R-INLA</strong> que permite organizar la información necesaria de una fórma verátil y cómoda para posteriormente ser integrada en la llamada a la función de ajuste <code>inla(...)</code>. La función empleada para ello es <code>inla.stack(...)</code>, la cual produce un objeto <code>inla.data.stack</code>.</p>
<h2 id="1-estructura-de-un-stack">1. Estructura de un <em>stack</em></h2>
<p>La función <code>inla.stack(...)</code> organiza la información de la variable respuesta (<em>data</em>), los efectos del modelo (<em>effects</em>) y la matriz de proyección (<em>A</em>), matriz 
<span class="math align-center">$\mathbf{A}$</span> que liga el campo latente 
<span class="math align-center">$\mathbf{\mathcal{X}}$</span> con el predictor lineal 
<span class="math align-center">$\boldsymbol\eta$</span>. Por tanto, se dispondrá de un argumento asociado a cada uno de estos tres elementos, que será definido a través de una lista, junto con otros argumentos como <code>tag</code> que permite nombrar dicho <em>stack</em> y así, posteriormente, extraer índices o información según la etiqueta del <em>stack</em>.</p>
<p>La estructura del código quedaría sintetizada en el siguiente bloque de código:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="kc">...</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="kc">...</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">effects</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="kc">...</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span> <span class="o">=</span> <span class="s">&#34;stack_label&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span></code></pre></div><p>La función <code>inla.stack(...)</code> permite agrupar (<em>stakear</em>) otros objetos que sean ellos mismos también objetos de la clase <code>inla.data.stack</code>. Esto se debe a que la propia función <code>inla.stack(...)</code> es una función que llama a otras dos, <code>inla.stack.sum(...)</code> e <code>inla.stack.join(...)</code>, según se los argumentos introducidos sean los anteriormente expuestos o sean objetos <code>inla.data.stack</code>. En el primer caso se llamaría a la función <code>inla.stack.sum(...)</code>, mientras que en el segundo se llamaría a la función <code>inla.stack.join(...)</code>.</p>
<p>Además, hay otros dos argumentos, ligados a la función <code>inla.stack.sum(...)</code> que pueden, ser de gran utilidad en determinados casos: <code>compress</code> y <code>remove.unused</code>. El primero eliminaría elementos duplicados en los efectos, y por tanto eliminaría las columnas asociadas a <em>A</em> relativas a dichos efectos, mientras que el segundo argumento eliminaría aquellos efectos que tienen valores nulos para toda la columna en <em>A</em> (eliminando también dichas columnas). Esto podremos observarlo en el pequeño ejemplo muy <em>naive</em> dedicado a un modelo espacial.</p>
<p>En definitiva, la función permite automatizar la organización de los datos, por la generación <code>NAs</code> donde es necesario en el <code>data.frame</code> de los efectos y la integración de las matrices de proyección de los efectos y de distintos <em>stacks</em> cuando son agregados. Además, permite que la estructura general del código sea más legible al poder escindir partes del modelo en distintos <em>stacks</em> y así facilitar la escritura y lectura de código al apoyarnos en estas funciones.</p>
<h2 id="2-ejemplos-de-uso-con-toy-models">2. Ejemplos de uso con <em>toy models</em></h2>
<p>En este apartado expondremos unos breves ejemplos del uso de los <em>stacks</em> con unos modelos muy sencillos. Estos modelos emplean datos simulados y pueden ser demasiado simples, particularmente el segundo es un ejemplo algo artificial pero el objeto es tratar de exponer ejemplos variados para formar <em>stacks</em>. Los ejemplos son:</p>
<ol>
<li>Un modelo con dos efectos fijos.</li>
<li>Un modelo con interceptor y un efecto aleatorio <em>iid</em>.</li>
<li>Un modelo con interceptor y un efecto aleatorio espacialmente estructurado.</li>
</ol>
<h3 id="21-modelo-lineal-sin-efectos-aleatorios">2.1 Modelo lineal sin efectos aleatorios</h3>
<p>En este ejemplo vamos a simular un modelo Gaussiano con un interceptor 
<span class="math align-center">$(\beta_0)$</span> y un efecto fijo asociado a una variable explicativa numérica continua 
<span class="math align-center">$(\beta_1, \mathbf{x}\in\mathbb{R})$</span>.</p>
<p>El código necesario para la simulación es el siguiente</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="m">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">beta_0</span> <span class="o">&lt;-</span> <span class="m">-2</span>
</span></span><span class="line"><span class="cl"><span class="n">beta_1</span> <span class="o">&lt;-</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl"><span class="n">lin_pred</span> <span class="o">&lt;-</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="n">beta_1</span><span class="o">*</span><span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">lin_pred</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">3</span><span class="p">)</span>
</span></span></code></pre></div><p>Dados estos datos, podemos organizar la información en un <em>stack</em> según cualquiera de las siguientes alternativas:</p>

<div class="tab-panel">
  <div class="tab-nav">
    <button
      data-tab-item="Alt. 1"
      data-tab-group="default"
      class="tab-nav-button direction-ltr active"
      onclick="switchTab('default','Alt. 1')"
      ><span>Alt. 1</span></button>
    <button
      data-tab-item="Alt. 2"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','Alt. 2')"
      ><span>Alt. 2</span></button>
    <button
      data-tab-item="Alt. 3"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','Alt. 3')"
      ><span>Alt. 3</span></button>
  </div>
  <div class="tab-content">
    <div data-tab-item="Alt. 1" data-tab-group="default" class="tab-item active">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="m">1E2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">beta_1</span><span class="o">=</span><span class="n">x</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="Alt. 2" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="m">1E2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">beta_1</span><span class="o">=</span><span class="n">x</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="Alt. 3" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="nf">Diagonal</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="m">1</span><span class="p">),</span> <span class="nf">Diagonal</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="m">1E2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">beta_1</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="m">1E2</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span></code></pre></div>
    </div>
  </div>
</div>
<p>Con independencia de cual de las alternativas escojamos para construir el <em>stack</em> podremos emplear el mismo código para llamar a la función <code>inla(...)</code> y ajustar el modelo.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inla_model</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">inla</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">formula</span><span class="o">=</span><span class="n">y</span><span class="o">~</span><span class="m">-1</span><span class="o">+</span><span class="n">beta_0</span><span class="o">+</span><span class="n">beta_1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">family</span><span class="o">=</span><span class="s">&#34;gaussian&#34;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nf">inla.stack.data</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">control.predictor</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="nf">inla.stack.A</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span></code></pre></div><p>En la función <code>inla(...)</code> el argumento <code>data</code> es relativo a los datos de los modelos, debiendo hacer coincidir los nombres de los elementos entre la fórmula y los almacenados en el <em>stack</em>, los datos se extraen (como una lista) mediante la función <code>inla.stack.data</code>. Por otro lado, <code>control.predictor</code> es un argumento que nos permite definir una lista de argumentos relativos a opciones de configuración del predictor, particulamente hacemos uso del argumento <code>A</code>, que define la matriz de proyección y que podemos extraer del <em>stack</em> mediante la función <code>inla.stack.A</code>.</p>
<h3 id="22-modelo-lineal-con-efecto-aleatorio-iid">2.2 Modelo lineal con efecto aleatorio <em>iid</em></h3>
<p>En este caso simularemos un modelo con un interceptor y con un efecto aleatorio <em>iid</em>. Para ello nos valemos del siguiente código:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">beta_0</span> <span class="o">&lt;-</span> <span class="m">-2</span>
</span></span><span class="line"><span class="cl"><span class="n">w</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="o">/</span><span class="m">2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="m">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">lin_pred</span> <span class="o">&lt;-</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="nf">c</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="nf">rep</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="m">50</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">1E2</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">lin_pred</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="m">0.1</span><span class="p">)</span>
</span></span></code></pre></div><p>En este caso estaríamos definiendo el predictor lineal como 
<span class="math align-center">$\boldsymbol\eta\equiv \left\lbrace \eta_{1:50}=\beta_0 + w_{1:50},\; \eta_{51:100}=\beta_0 \right\rbrace $</span>, tal que 
<span class="math align-center">$ \mathbf{w} \sim N(0, \tau=0.04)$</span>. La definición del <em>stack</em> ahora será un poco distinta, dado que debemos definir el interceptor para todo el predictor lineal y separar los dos efectos <em>iid</em> según la posición asociada al predictor. Algunas alternativas posibles de escribir correctamente los datos en un <em>stack</em> son las siguientes:</p>

<div class="tab-panel">
  <div class="tab-nav">
    <button
      data-tab-item="Alt. 1"
      data-tab-group="default"
      class="tab-nav-button direction-ltr active"
      onclick="switchTab('default','Alt. 1')"
      ><span>Alt. 1</span></button>
    <button
      data-tab-item="Alt. 2"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','Alt. 2')"
      ><span>Alt. 2</span></button>
  </div>
  <div class="tab-content">
    <div data-tab-item="Alt. 1" data-tab-group="default" class="tab-item active">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="m">100</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">w</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">50</span><span class="p">,</span><span class="nf">rep</span><span class="p">(</span><span class="kc">NA</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="m">50</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span><span class="p">)</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="Alt. 2" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="m">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nf">Diagonal</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="m">100</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="m">50</span><span class="p">),</span><span class="nf">rep</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="m">50</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="m">100</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">w</span><span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="m">100</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span><span class="p">)</span>
</span></span></code></pre></div>
    </div>
  </div>
</div>
<p>Finalmente, la llamada a la función de ajuste es idéntica al anterior caso, con la excepción de que el argumento de la fórmula debemos cambiarlo para el nuevo modelo.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inla_model</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">    <span class="n">formula</span><span class="o">=</span><span class="n">y</span><span class="o">~</span><span class="m">-1</span> <span class="o">+</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s">&#34;iid&#34;</span><span class="p">,</span> <span class="n">constr</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">family</span><span class="o">=</span><span class="s">&#34;gaussian&#34;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nf">inla.stack.data</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">control.predictor</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="nf">inla.stack.A</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></div><h3 id="23-modelo-lineal-con-efectos-aleatorios-espacialmente-estructurados">2.3 Modelo lineal con efectos aleatorios espacialmente estructurados</h3>
<p>En este último ejemplo simularemos datos con estructura espacial, en el que aprovecharemos para mostrar las diferencias de dejar algunos argumentos de forma predeterminada en la función <code>inla.stack(...)</code>.</p>
<p>La simulación de datos con dependencia espacial podemos hacerlo mediante el siguiente código, en el que se configura una malla, y los objetos necesarios del SPDE para simular un campo Gaussiano con función de covarianzas tipo Matèrn.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">mesh</span> <span class="o">&lt;-</span> <span class="nf">inla.mesh.2d</span><span class="p">(</span><span class="n">loc.domain</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                                         <span class="n">ncol</span><span class="o">=</span><span class="m">2</span><span class="p">,</span> <span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                     <span class="n">max.edge</span> <span class="o">=</span> <span class="nf">c</span><span class="p">(</span><span class="m">0.05</span><span class="p">,</span><span class="m">0.1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">spde</span> <span class="o">&lt;-</span> <span class="nf">inla.spde2.pcmatern</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="n">alpha</span> <span class="o">=</span> <span class="m">2</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="n">prior.range</span> <span class="o">=</span> <span class="nf">c</span><span class="p">(</span><span class="m">0.2</span><span class="p">,</span><span class="m">0.5</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                            <span class="n">prior.sigma</span> <span class="o">=</span> <span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">0.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Q</span> <span class="o">&lt;-</span> <span class="nf">inla.spde2.precision</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">spde</span><span class="o">=</span><span class="n">spde</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">theta</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="nf">log</span><span class="p">(</span><span class="m">0.2</span><span class="p">),</span><span class="nf">log</span><span class="p">(</span><span class="m">1</span><span class="p">))</span> <span class="c1"># log(range), log(stdev.)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">u</span> <span class="o">&lt;-</span> <span class="nf">inla.qsample</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sample.locations</span> <span class="o">&lt;-</span> <span class="nf">matrix</span><span class="p">(</span><span class="nf">runif</span><span class="p">(</span><span class="m">5E2</span><span class="p">),</span> <span class="n">ncol</span><span class="o">=</span><span class="m">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">A_u</span> <span class="o">&lt;-</span> <span class="nf">inla.spde.make.A</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">sample.locations</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">beta_0</span> <span class="o">&lt;-</span> <span class="m">-2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">lin_pred</span> <span class="o">&lt;-</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="nf">as.vector</span><span class="p">(</span><span class="n">A_u</span> <span class="o">%*%</span> <span class="n">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="nf">length</span><span class="p">(</span><span class="n">lin_pred</span><span class="p">),</span> <span class="n">mean</span> <span class="o">=</span> <span class="n">lin_pred</span><span class="p">,</span> <span class="n">sd</span> <span class="o">=</span> <span class="m">0.25</span><span class="p">)</span>
</span></span></code></pre></div><p>Las localizaciones de simulación son <code>sample.locations</code>, tal que el efecto espacial se simula en los nodos de la malla a dichas localizaciones a través de la matriz de proyección <code>A_u</code>, matriz que también será integrada en el <em>stack</em> para la matriz de proyección del efecto espacial.</p>
<p>El <em>stack</em> para el modelo espacial podemos contruirlo según el siguiente código:</p>

<div class="tab-panel">
  <div class="tab-nav">
    <button
      data-tab-item="Alt. 1"
      data-tab-group="default"
      class="tab-nav-button direction-ltr active"
      onclick="switchTab('default','Alt. 1')"
      ><span>Alt. 1</span></button>
    <button
      data-tab-item="Alt. 2"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','Alt. 2')"
      ><span>Alt. 2</span></button>
    <button
      data-tab-item="Alt. 3"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','Alt. 3')"
      ><span>Alt. 3</span></button>
    <button
      data-tab-item="Alt. 4"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','Alt. 4')"
      ><span>Alt. 4</span></button>
  </div>
  <div class="tab-content">
    <div data-tab-item="Alt. 1" data-tab-group="default" class="tab-item active">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">A_u</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">spatial</span><span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="n">spde</span><span class="o">$</span><span class="n">n.spde</span>
</span></span><span class="line"><span class="cl">      <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="Alt. 2" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">A_u</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">spatial</span><span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="n">spde</span><span class="o">$</span><span class="n">n.spde</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="Alt. 3" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">A_u</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">spatial</span><span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="n">spde</span><span class="o">$</span><span class="n">n.spde</span>
</span></span><span class="line"><span class="cl">      <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">compress</span> <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">remove.unused</span> <span class="o">=</span> <span class="kc">FALSE</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="Alt. 4" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inf_stack</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla.stack</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">A_u</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">effects</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">beta_0</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">spatial</span><span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="n">spde</span><span class="o">$</span><span class="n">n.spde</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">compress</span> <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">remove.unused</span> <span class="o">=</span> <span class="kc">FALSE</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></div>
    </div>
  </div>
</div>
<p>En las alternativas 1 y 2 simplemente tenemos dos formas distintas de formar el <em>stack</em>, mientras que las alternativas 3 y 4 son respectivamente la 1 y 2, pero eliminando la compresión o simplificación de la matriz de proyección y de los efectos. Si comparamos la matriz de proyección almacenada en el objeto <code>inf_stack</code>, entre las alternativas 1-2 y 3-4 podremos observar que las dimensiones para las dos primeras es inferior a las de las dos últimas, dado que se eliminarían los índices del efecto espacial asociados a las columnas de la matriz de proyección cuyas columnas sólo contengan valores nulos (debido al argumento predeterminado <code>remove.unused = TRUE</code>), junto con la eliminación de estas columnas de valores cero.</p>
<p>Finalmente para ajustar el modelo el código necesario es básicamente el ya empleado, pero cambiando la expresión de la fórmula para el modelo.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">inla_model</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">inla</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">    <span class="n">formula</span><span class="o">=</span><span class="n">y</span><span class="o">~</span><span class="m">-1</span> <span class="o">+</span> <span class="n">beta_0</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="n">spatial</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">spde</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">family</span><span class="o">=</span><span class="s">&#34;gaussian&#34;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nf">inla.stack.data</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">control.predictor</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="nf">inla.stack.A</span><span class="p">(</span><span class="n">inf_stack</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></div><h2 id="3-funciones-extras-para-los-stacks">3. Funciones extras para los <em>stacks</em></h2>
<p>Otras funciones que podemos utilizar sobre los <em>stacks</em> son <code>inla.stack.index(...)</code>, <code>inla.stack.LHS(...)</code> y <code>inla.stack.RHS(...)</code>.</p>
<p>La primera función requiere de dos argumentos, el <code>stack</code> y la etiqueta <code>tag</code> para la extracción de índices de los datos y los efectos. Esto es, si consideramos algunos de los ejemplos previos podríamos emplear esta función como</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">index</span> <span class="o">&lt;-</span> <span class="nf">inla.stack.index</span><span class="p">(</span><span class="n">stack</span><span class="o">=</span><span class="n">inf_stack</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s">&#34;inf_stack&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>El cual devuelve una lista con dos elementos, <code>data</code> y <code>effects</code>, con los correspondientes índices de los datos y los efectos que podemos emplear para extraerlos de la salida del ajuste del modelo para el predictor lineal.</p>
<p>Las otras dos funciones permite extraer los valores de los elementos del lado izquierdo de la fórmula (<code>inla.stack.LHS(...)</code>) y los del lado derecho (<code>inla.stack.RHS(...)</code>). En ambos casos sólo se necesita especificar el <em>stack</em> sobre el que se aplicará la función.</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
<h1 id="conformaci%C3%B3n-de-mallas">Conformación de Mallas</h1>


            <footer class="footline">
            </footer>
          </article>

          <article class="default">
<h1 id="caracter%C3%ADsticas-avanzadas">Características Avanzadas</h1>


            <footer class="footline">
            </footer>
          </article>

          </section>
          <article class="default">
<h1 id="extensiones-de-inla">Extensiones de INLA</h1>

<p>En esta sección realizamos una pequeña recopilación de paquetes o librerías que resultan en extensiones del paquete <strong>R-INLA</strong>.</p>

<ul class="children children-li children-sort-weight">
	
<li><a href="../../es/inla/extensions/dirinla/index.html">dirinla</a><p>Ejemplos empleando el paquete dirinla para Datos Composicionales (CoDa).</p></li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsecciones de Extensiones de INLA</h1>
          <article class="default">
<h1 id="dirinla">dirinla</h1>

<p>Esta sección está dedicada específicamente al paquete <strong>dirinla</strong> que está construido sobre el enfoque implementado en <strong>R-INLA</strong>. Para que los ejemplos resulten comprensibles dedicaremos esta espacio introductorio para sintetizar los fundamentos matemáticos y operativos de <strong>dirinla</strong>. Esto es, realizaremos una síntesis del artículo <a href="https://doi.org/10.1080/10618600.2022.2144330">(Martínez-Minaya et al., 2023)</a> en el que se presenta el paquete y también se evaluarán algunas de las funciones que lo integran, modificándolas allí donde se considere pertinente.</p>
<h2 id="ejemplos">Ejemplos</h2>

<ul class="children children-li children-sort-weight">
	
<li><a href="../../es/inla/extensions/dirinla/linear_effects/index.html">Ejemplos con efectos fijos</a><p>Datos Dirichlet simulados ajustados con un modelo de efectos fijos.</p></li>
<li><a href="../../es/inla/extensions/dirinla/unstructure_random_effects/index.html">Ejemplos con efectos iid aleatorios</a><p>Datos Dirichlet simulados ajustados con un modelo de efectos iid aleatorios.</p></li>
<li><a href="../../es/inla/extensions/dirinla/spde2_random_effects/index.html">Ejemplos con efectos aleatorios espacialmente estructurados</a><p>Datos Dirichlet simulados ajustados con un modelo de efectos aleatorios espacialmente estructurados.</p></li>
</ul>
<h2 id="inla-for-fitting-dirichlet-regression-models-resumen">INLA for Fitting Dirichlet Regression Models (Resumen)</h2>
<p>Este es un breve resumen del artículo <a href="https://doi.org/10.1080/10618600.2022.2144330">(Martínez-Minaya et al., 2023)</a> en el que se presenta la metodología en la que se basa el paquete, junto con algunos casos de estudio y comparativas con métodos MCMC, concretamente empleando <a href="https://www.jstor.org/stable/26447820">JAGS</a>.</p>
<h2 id="evaluación-y-modificación-de-funciones">Evaluación y Modificación de funciones</h2>
<h2 id="referencias">Referencias</h2>
<ol>
<li>
<div class="csl-entry"> Joaquín Martínez-Minaya, Finn Lindgren, Antonio López-Quílez, Daniel Simpson & David Conesa (2023) The Integrated Nested Laplace Approximation for Fitting Dirichlet Regression Models, Journal of Computational and Graphical Statistics, 32:3, 805-823, DOI: <a href="https://doi.org/10.1080/10618600.2022.2144330">https://doi.org/10.1080/10618600.2022.2144330</a> </div>
</li>
<li>
<div class="csl-entry"> Depaoli, S., Clifton, J. P., & Cobb, P. R. (2016). Just Another Gibbs Sampler (JAGS): Flexible Software for MCMC Implementation. Journal of Educational and Behavioral Statistics, 41(6), 628–649. <a href="http://www.jstor.org/stable/26447820">http://www.jstor.org/stable/26447820</a> </div></li>
</ol>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsecciones de dirinla</h1>
          <article class="default">
<h1 id="ejemplos-con-efectos-fijos">Ejemplos con efectos fijos</h1>


            <footer class="footline">
            </footer>
          </article>

          <article class="default">
<h1 id="ejemplos-con-efectos-iid-aleatorios">Ejemplos con efectos iid aleatorios</h1>

<p>Esta sección está dedicada específicamente al paquete <strong>dirinla</strong> que está construido sobre el enfoque implementado en <strong>R-INLA</strong>. Para que los ejemplos resulten comprensibles dedicaremos esta espacio introductorio para sintetizar los fundamentos matemáticos y operativos de <strong>dirinla</strong>. Esto es, realizaremos una síntesis del artículo <a href="https://doi.org/10.1080/10618600.2022.2144330">(Martínez-Minaya et al., 2023)</a> en el que se presenta el paquete y también se evaluarán algunas de las funciones que lo integran, modificándolas allí donde se considere pertinente.</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
<h1 id="ejemplos-con-efectos-aleatorios-espacialmente-estructurados">Ejemplos con efectos aleatorios espacialmente estructurados</h1>

<p>Esta sección está dedicada específicamente al paquete <strong>dirinla</strong> que está construido sobre el enfoque implementado en <strong>R-INLA</strong>. Para que los ejemplos resulten comprensibles dedicaremos esta espacio introductorio para sintetizar los fundamentos matemáticos y operativos de <strong>dirinla</strong>. Esto es, realizaremos una síntesis del artículo <a href="https://doi.org/10.1080/10618600.2022.2144330">(Martínez-Minaya et al., 2023)</a> en el que se presenta el paquete y también se evaluarán algunas de las funciones que lo integran, modificándolas allí donde se considere pertinente.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
          </section>
          <article class="default">
<h1 id="funciones-varias">Funciones Varias</h1>

<p>Aquí se expondran distintas funciones que se han ido desarrollando para su implementación en procesos automatizados o que puedan resultar de interés.</p>

<ul class="children children-li children-sort-weight">
	
<li><a href="../../es/inla/variousfunctions/inlatosp/index.html">Transformación a sp/sf</a><p>Aquí definimos algunas funciones relativas a la transformación de un objeto inla.mesh a un objeto sp/sf.</p></li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsecciones de Funciones Varias</h1>
          <article class="default">
<h1 id="transformaci%C3%B3n-a-sp/sf">Transformación a sp/sf</h1>


<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info"></i> Información de versiones</div>
    <div class="box-content">
<p>En este rótulo inicial exponemos una lista con las versiones de los programas, sistema operativo y librearías con las que se ha ejecutado el código de la presente sección, lo cual se extrae principalmente mediante la función <code>sessionInfo()</code>.</p>
<ul>
<li>SO (version): Windows 11 Home (22H2).</li>
<li>R: 4.2.2 (2022-10-31 ucrt).</li>
<li>RStudio: 2022.07.2 (Build 576).</li>
<li>Libraries:
<ul>
<li>INLA: INLA_22.05.07</li>
<li>inlabru: inlabru_2.5.3</li>
<li>sp: sp_1.5-0</li>
<li>sf: sf_1.0-8</li>
<li>ggplot: ggplot2_3.3.6</li>
<li>viridis: viridis_0.6.2</li>
</ul>
</li>
</ul>
    </div>
</div>
<p>Puden darse casos en los que se requiera trabajar con elementos de <code>inla</code> como si fuesen objetos espaciales (usualmente <code>sp</code> o <code>sf</code>), esto será particularmente propia cuando se trabajen con las mallas o los bordes de las mismas. Sea cualesquiera los motivos por los que se requiera pasar la malla o los bordes de la misma a objetos espaciales, no se dispone de una función integrada en <code>library(INLA)</code>, por lo que se procederá a su definición.</p>
<h2 id="malla-a-objeto-espacial">Malla a objeto espacial</h2>
<p>Supongamos que partimos de un conjunto de puntos dados por el <em>data frame</em> <code>XY</code>, sobre el cual aplicamos la función <code>inla.nonconvex.hull</code> para obtener la frontera de nuestra malla, resultado de las operaciones morfológicas de dilatación y cierre incorporadas para la formación del borde exterior.</p>

<span class="btn cstyle transparent">
  <a href="../../es/inla/variousfunctions/inlatosp/index.html/XY.rds">
    <i class="fas fa-download"></i>
    Get <code>XY</code> data
  </a>
</span>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="nf">library</span><span class="p">(</span><span class="n">INLA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">library</span><span class="p">(</span><span class="n">inlabru</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">XY</span> <span class="o">&lt;-</span> <span class="nf">readRDS</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s">&#34;XY.rds&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">INLAnonconvex</span> <span class="o">&lt;-</span> <span class="nf">inla.nonconvex.hull</span><span class="p">(</span><span class="n">XY</span><span class="p">,</span> <span class="n">convex</span><span class="o">=</span><span class="m">1000</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="m">400</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">INLAnonconvexMesh</span> <span class="o">&lt;-</span> <span class="nf">inla.mesh.2d</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="n">INLAnonconvex</span><span class="p">,</span> <span class="n">max.edge</span><span class="o">=</span><span class="m">5000</span><span class="p">)</span>
</span></span></code></pre></div><p>Si graficamos la malla <code>ggplot() + inlabru::gg(INLAnonconvexMesh) + theme_void()</code> obtendremos la siguiente figura:</p>
<table>
<thead>
<tr>
<th style="text-align:center"><b>Fig. 1: INLA mesh with non convex boundary</b></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
		
<a href="../../es/inla/variousfunctions/inlatosp/INLAmesh.png?&amp;width=25pc" data-featherlight="image">
<img src="../../es/inla/variousfunctions/inlatosp/INLAmesh.png?&amp;width=25pc" alt="INLA_mesh_with_non_convex_boundary.png" style="height: auto; width: 25pc;" loading="lazy">
</a></td>
</tr>
</tbody>
</table>
<p>Una vez se dispone de la malla, para transformar la teselación en un objeto espacial (<code>sp</code>) nos valemos de la información integrada en el objeto de la malla (<code>mesh</code>). Concretamente en las filas de la matriz <code>mesh$graph$tv</code>, que almacenan las posiciones de los vértices para cada i-ésimo triángulo. De esta forma, simplemente inscribimos los índices de los vértices para cada triángulo en la matriz de coordenadas de los propios vértices, formando un polígono con cada uno y agrupandando finalmente el resultado en un objeto <code>SpatialPolygons</code>, o en un  Esto queda sintetizado en la siguiente función:</p>

<div class="tab-panel">
  <div class="tab-nav">
    <button
      data-tab-item="sp"
      data-tab-group="default"
      class="tab-nav-button direction-ltr active"
      onclick="switchTab('default','sp')"
      ><span>sp</span></button>
    <button
      data-tab-item="sf"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','sf')"
      ><span>sf</span></button>
  </div>
  <div class="tab-content">
    <div data-tab-item="sp" data-tab-group="default" class="tab-item active">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">SpatialPolygonDelaunay</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">mesh</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nf">return</span><span class="p">(</span><span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">nrow</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">graph</span><span class="o">$</span><span class="n">tv</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">list</span><span class="p">(</span><span class="nf">Polygons</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">Polygon</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">loc[mesh</span><span class="o">$</span><span class="n">graph</span><span class="o">$</span><span class="n">tv[i</span><span class="p">,</span><span class="n">]</span><span class="p">,</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="n">]</span><span class="p">)),</span><span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="sf" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">SpatialPolygonDelaunay</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">mesh</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nf">return</span><span class="p">(</span><span class="nf">st_polygon</span><span class="p">(</span><span class="nf">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">nrow</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">graph</span><span class="o">$</span><span class="n">tv</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">list</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">loc</span><span class="nf">[c</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">graph</span><span class="o">$</span><span class="n">tv[i</span><span class="p">,</span><span class="n">]</span><span class="p">,</span> <span class="n">mesh</span><span class="o">$</span><span class="n">graph</span><span class="o">$</span><span class="n">tv[i</span><span class="p">,</span><span class="m">1</span><span class="n">]</span><span class="p">),</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="n">]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
    </div>
  </div>
</div>
<p>Tal que el objeto ya convertido lo tendríamos como:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">SpatialPolygonMesh</span> <span class="o">&lt;-</span> <span class="nf">SpatialPolygonDelaunay</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">INLAnonconvexMesh</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="borde-a-objeto-espacial">Borde a objeto espacial</h2>
<p>En este caso se pretendenden transformar los bordes de la malla a <code>SpatialPolygons</code>, de tal forma que se pueda dar cuenta de los huecos presentes en la misma. Entonces, lo primero a realizar es convertir los bordes en polígonos simplemente conexos (sin huecos).</p>
<p>Para conformar correctamente un polígono se debe indicar el orden de sucesión de los puntos del perímetro del mismo, tal que el el primer punto sea también el último para cerrar el polígono. Esto se puede realizar fácilmente gracias a que la malla almacena las localizaciones de los vértices que componen los bordes como pares de puntos en las filas de la matriz <code>mesh$segm$bnd$idx</code>. Esto es, si los puntos se refieren al mismo polígono tendremos la conexión establecida a partir de los pares de índices recorriendo las filas de esta matriz, tal que se llegará a repetir en la primera columna la posición del punto inicial para cerrar el polígono.</p>
<p>Por tanto, sabiendo que la secuencia de índices para cada curva cerrada implica que el último par acabe en el primer punto (primer par de índices), tendremos que el elemento de la primera columna de la siguiente fila será diferente del elemento de la segunda columna de la fila de referencia: <code>mesh$segm$bnd$idx[i+1,1]!=mesh$segm$bnd$idx[i,1]</code>. Por lo que, a través de esta condición, podemos establecer los índices de los límites de los polígonos que querremos reconstruir como objetos espaciales (<code>sp</code> o <code>sf</code>).</p>

<div class="tab-panel">
  <div class="tab-nav">
    <button
      data-tab-item="sp"
      data-tab-group="default"
      class="tab-nav-button direction-ltr active"
      onclick="switchTab('default','sp')"
      ><span>sp</span></button>
    <button
      data-tab-item="sf"
      data-tab-group="default"
      class="tab-nav-button direction-ltr "
      onclick="switchTab('default','sf')"
      ><span>sf</span></button>
  </div>
  <div class="tab-content">
    <div data-tab-item="sp" data-tab-group="default" class="tab-item active">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">SpatialPolygonsBoundary</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">mesh</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">BoundaryIndx</span> <span class="o">&lt;-</span> <span class="nf">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="nf">nrow</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx</span><span class="p">)</span><span class="m">-1</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">return</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx[i</span><span class="m">+1</span><span class="p">,</span><span class="m">1</span><span class="n">]</span><span class="o">==</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx[i</span><span class="p">,</span><span class="m">2</span><span class="n">]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="n">BoundaryIndxLims</span> <span class="o">&lt;-</span> <span class="nf">which</span><span class="p">(</span><span class="o">!</span><span class="n">BoundaryIndx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">BoundaryIndxLims</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">BoundaryIndxLims</span><span class="p">,</span> <span class="nf">nrow</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="n">SpatialPolygonsBoundary</span> <span class="o">&lt;-</span> <span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">sapply</span><span class="p">(</span><span class="m">2</span><span class="o">:</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">BoundaryIndxLims</span><span class="p">)),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">VertixBoundaryIndex</span> <span class="o">&lt;-</span> <span class="nf">matrix</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx</span><span class="nf">[</span><span class="p">(</span><span class="n">BoundaryIndxLims[i</span><span class="m">-1</span><span class="n">]</span><span class="m">+1</span><span class="p">)</span><span class="o">:</span><span class="n">BoundaryIndxLims[i]</span><span class="p">,</span><span class="m">1</span><span class="n">]</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx[BoundaryIndxLims[i]</span><span class="p">,</span><span class="m">2</span><span class="n">]</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                                  <span class="n">ncol</span><span class="o">=</span><span class="m">1</span><span class="p">,</span> <span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">Polygons</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">Polygon</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">loc[VertixBoundaryIndex</span><span class="p">,</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="n">]</span><span class="p">)),</span><span class="n">i</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">  <span class="p">}))</span>
</span></span><span class="line"><span class="cl">  <span class="nf">return</span><span class="p">(</span><span class="n">SpatialPolygonsBoundary</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
    </div>
    <div data-tab-item="sf" data-tab-group="default" class="tab-item ">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">SpatialPolygonsBoundary</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">mesh</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">BoundaryIndx</span> <span class="o">&lt;-</span> <span class="nf">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="nf">nrow</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx</span><span class="p">)</span><span class="m">-1</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">return</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx[i</span><span class="m">+1</span><span class="p">,</span><span class="m">1</span><span class="n">]</span><span class="o">==</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx[i</span><span class="p">,</span><span class="m">2</span><span class="n">]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="n">BoundaryIndxLims</span> <span class="o">&lt;-</span> <span class="nf">which</span><span class="p">(</span><span class="o">!</span><span class="n">BoundaryIndx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">BoundaryIndxLims</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">BoundaryIndxLims</span><span class="p">,</span> <span class="nf">nrow</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="n">SpatialPolygonsBoundary</span> <span class="o">&lt;-</span> <span class="nf">st_polygon</span><span class="p">(</span><span class="nf">sapply</span><span class="p">(</span><span class="m">2</span><span class="o">:</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">BoundaryIndxLims</span><span class="p">)),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">VertixBoundaryIndex</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx</span><span class="nf">[</span><span class="p">(</span><span class="n">BoundaryIndxLims[i</span><span class="m">-1</span><span class="n">]</span><span class="m">+1</span><span class="p">),</span><span class="m">1</span><span class="n">]</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                             <span class="n">mesh</span><span class="o">$</span><span class="n">segm</span><span class="o">$</span><span class="n">bnd</span><span class="o">$</span><span class="n">idx</span><span class="nf">[</span><span class="p">(</span><span class="n">BoundaryIndxLims[i</span><span class="m">-1</span><span class="n">]</span><span class="m">+1</span><span class="p">)</span><span class="o">:</span><span class="n">BoundaryIndxLims[i]</span><span class="p">,</span><span class="m">2</span><span class="n">]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">cbind</span><span class="p">(</span><span class="n">mesh</span><span class="o">$</span><span class="n">loc[VertixBoundaryIndex</span><span class="p">,</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="n">]</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">  <span class="p">}))</span>
</span></span><span class="line"><span class="cl">  <span class="nf">return</span><span class="p">(</span><span class="n">SpatialPolygonsBoundary</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
    </div>
  </div>
</div>
<!-- Con respecto a los polígonos obtenidos por `sf`, si se representa el resultado gráficamente, puede parecer que estos ya están teniendo en cuenta aquellos que son huecos, pero si hacemos la representación gráfica de cad uno de ellos se patentiza que estos no presentan huecos. Por tanto, si queremos realizar operaciones con los polígonos, detal forma que tengan en cuenta los intersticios, se tendrán que realizar las mismas transformaciones que para los polígonos dados para `sp`. -->
<p>Entonces, una vez se han conformado todos los polígonos a partir de los bordes dados por la función de <code>INLA</code>, se deben transformar estos polígonos para dar cuenta de los huecos que puedan contener y están presentes. Para ello podemos realizar una planteamiento matemático de las propiedades del problema, empleando teoría de conjuntos para conjuntos ordenados, o bien plantearlo de forma operacional para su resolución.</p>

<div class="expand">
    <a class="expand-label" onclick="$t=$(this); if($t.parent('.expand-expanded.expand-marked').length){ $t.next().css('display','none') }else if($t.parent('.expand-marked').length){ $t.next().css('display','block') }else{ $t.next('.expand-content').slideToggle(100); } $t.parent().toggleClass('expand-expanded');">
        <i class="fas fa-chevron-down"></i>
        <i class="fas fa-chevron-left expand-rtl direction-ltr"></i>
        <i class="fas fa-chevron-right expand-ltr direction-ltr"></i>
        Plantemiento operacional.
    </a>
    <div class="expand-content" style="display: none;">
<p>Para realizarlo según un plateamiento operacional debemos considerar que hemos formado un polígono por cada curva cerrada, por cada borde o frontera, de tal forma que estas curvas podrán contener en su interior a otras superficies dadas por otras curvas. Además, algunos de estos polígonos podrán estar asociados al borde interior de los polígonos, los cuales remitirían a la frontera del hueco interno de dicho polígono, tal que podremos tener clasificar los polígonos obtenidos en dos clases o tipos: <em>polígonos llenos</em> y <em>polígonos huecos</em>, según remitan al borde de un área &ldquo;llena&rdquo; o un área &ldquo;hueca&rdquo;. Además, se tiene que tener en cuenta que un polígono lleno contendrán en el siguiente nivel de intersección máxima interna, en caso de contener en su interior otros polígonos, un <em>polígono hueco</em>. Mientras que para el caso de los <em>polígonos huecos</em> esta condición supone la contrarecíproca; a saber, que el siguiente nivel de intersección máxima interna será un <em>polígono lleno</em>. Tal que el nivel de interseccionalidad máxima interna respecto de un polígono dado lo entenderemos como el polígono de mayor área que esté completamente contenido en el polígono de referencia. Pero podemos ampliar esta definición según los distintos conjuntos de polígonos mutuamente independientes, donde la interseccionalidad máxima interna para el polígono de referencia ya no sea un único polígono, sino el mayor polígono de cada uno de estos conjuntos mutuamente disjuntos.</p>
<p>Por otro lado, si un polígono, delimitado por una de estas curvas dadas, tiene una intersección no nula con otros, entonces esta intersección reproducirá totalmente uno de los dos polígonos.</p>
<p>Posteriormente, si análogamente a una matriz de adyacencia o vecindad, elaboramos una <em>matriz de interseccionalidad</em>, determinada según la operación de intersección de un polígono dado sobre el resto de polígonos. Tal que la matriz contendrá las relaciones entre un polígono dado con todo el conjunto de polígonos según la operación de intersección, operación que valdrá 1 si hay intersección y 0 si no la hay. Por tanto, por cada fila o columna obtendremos la intersección de un polígono con el resto, donde la diagonal de la matriz manifestaría la intersección de un polígono consigo mismo, por lo que la diagonal principal será un vector de unos.</p>
<p>De la <em>matriz de interseccionalidad</em> podemos concluir que las filas o columnas cuya suma resulte unitaria (únicamente el elemento de la diagonal principal resultará distinto de 0 para esa fila o columna), pertenecerán a un polígono que no contendrá ningún otro polígono, sea este hueco o lleno. Por tanto, podríamos extraer estos polígonos como polígonos correctamente definidos y que no requieren de transformación alguna.</p>
<p>Finalmente, en caso de que una fila dada sume más de uno implicará que, al menos, contiene un hueco. Por lo que para formar los polígonos con los huecos podemos plantear el procedimiento de la siguiente forma:</p>
<ol>
<li>Primero, para cada fila se puede buscar el polígono de menor tamaño (área) en todo el conjunto de polígonos intersectantes, a partir del cual se construirá un conjunto completamente ordenado según las intersecciones del mismo.</li>
<li>Seguidamente, se puede recomponer el conjunto de polígonos como la reordenación en la menor cantidad de conjuntos totalmente ordenados. Tal que de estos conjuntos totalmente ordenados sabremos que el mayor de los conjuntos remite a un polígono lleno, el siguiente a uno hueco, &hellip; y así sucesivamente.</li>
<li>Para en tercer lugar, conformar mediante operaciones de diferencia y unión los distintos polígonos que den cuenta de los huecos existentes.</li>
</ol>

    </div>
</div>

<div class="expand">
    <a class="expand-label" onclick="$t=$(this); if($t.parent('.expand-expanded.expand-marked').length){ $t.next().css('display','none') }else if($t.parent('.expand-marked').length){ $t.next().css('display','block') }else{ $t.next('.expand-content').slideToggle(100); } $t.parent().toggleClass('expand-expanded');">
        <i class="fas fa-chevron-down"></i>
        <i class="fas fa-chevron-left expand-rtl direction-ltr"></i>
        <i class="fas fa-chevron-right expand-ltr direction-ltr"></i>
        Plantemiento matemático.
    </a>
    <div class="expand-content" style="display: none;">
<p>Desde un enfoque matemático podemos emplear teoría de conjuntos para evaluar el conjunto de operaciones a realizar para resolver la cuestión. Para ello, lo primero que debemos hacer es establecer las condiciones del problema:</p>
<ol>
<li>Tenemos un conjunto de
<span class="math align-center">$n$</span> polígonos
<span class="math align-center">$p_i$</span>, tal que el conjunto universal de referencia será
<span class="math align-center">$\displaystyle P=\{p_1, &hellip;, p_n\}$</span>. Tal que estos polígonos son subconjuntos del espacio Euclídeo de dos dimensiones,
<span class="math align-center">$p_i\subset \mathbb{R}^2$</span>.</li>
<li>Existen dos tipos de polígonos: (i) polígonos llenos (o <em>fill</em>)
<span class="math align-center">$P_{F}=\{p_{fi}\}$</span> y (ii) polígonos huecos (o <em>holes</em>)
<span class="math align-center">$P_H=\{p_{hi}\}$</span>, tal que
<span class="math align-center">$P=P_F\cup P_H$</span>.</li>
<li>Existe una función
<span class="math align-center">$f$</span> que establece la relación entre un polígono
<span class="math align-center">$p_i$</span> con su área
<span class="math align-center">$a_i$</span>, tal que
<span class="math align-center">$f:P\longmapsto A$</span> es
<span class="math align-center">$f(p_i)=a_i$</span>. No obstante, esta función es sólo sobreyectiva si asumimos que puede haber dos o más polígonos con la misma área, mientras que sería sobreyectiva e inyectiva si para cada polígono tiene un área distinta.</li>
<li>Si la intersección de dos polígonos es no nula, entonces la intersección resulta en el polígono de menor área. Esto es,
<span class="math align-center">$p_i\cap p_j=\{\emptyset\veebar p_j\}|f(p_i)&gt;f(p_j)$</span>. Además, tenemos como condición que no existe ningún polígono que intersectando con otro tenga su misma área,
<span class="math align-center">$(\nexists p_i)(p_i,p_j\in P): f(p_i)=f(p_j)\iff \{p_i\cap p_j\neq \emptyset \wedge i\neq j\}$</span>.</li>
<li>Para el conjunto de todas las intersecciones no nulas de polígonos
<span class="math align-center">$(p_i, p_j)$</span>, tendremos que el conjunto con mayor área es un <em>polígono lleno</em>
<span class="math align-center">$f(p_i)&gt;f(p_j):p_i\in P_F$</span>.</li>
<li>Finalmente, como condición debil entre la intersección no nula de dos <em>polígonos llenos</em>, tenemos que existe, al menos, un <em>polígono hueco</em> con mayor área que la del polígono lleno de menor área y que también intersecta con los mismos. Dicho de otro modo, si
<span class="math align-center">$p_j\subset p_i:p_i,p_j\in P_F\Rightarrow (\exists p_k) p_k\in P_H: p_j\subset p_k\subset p_i$</span>. Mientras que la condición fuerte será, que si tenemos dos polígonos tal que uno es subconjunto de otro sin nungún <em>polígono lleno</em> que puede incorporarse como elemento medio entre ambos mediante la operación de subconjunto-de, entonces existe un y sólo un <em>polígono hueco</em> que intermedia entre ambos:</li>
</ol>
<span class="math align-center">
$$(\forall p_i,p_j\in P_F) p_j\subset p_i:\nexists p_k\in P_F, p_j \subset p_k \wedge p_k\subset p_i \iff \exists! p_z\in P_H: p_j\subset p_z \wedge p_z\subset p_i.$$
</span>
<p>Dadas estas condiciones es obvio que puede reordenarse el conjunto
<span class="math align-center">$P$</span> de todos los polígonos, de tal forma que tengamos el menor número de conjuntos completamente ordenados de mayor cardinalidad cuya unión reproduzca el conjunto
<span class="math align-center">$P$</span> de referencia. Es decir, tenemos que conformar todos aquellos conjuntos completamente ordenados
<span class="math align-center">$(P_i,\subset)$</span>, lo cual implica que
<span class="math align-center">$(\forall p_i) p_i\in P_i (\exists p_j)p_j\in P_i\rightarrow p_j\subset p_i \vee p_i\subset p_j$</span>. Por tanto, debemos construir estos conjuntos completamente ordenados
<span class="math align-center">$P_i=\{p_{i1}\subset p_{2i}\subset &hellip; \subset p_{ni}\}$</span>, de los que sabemos por las condiciones (5) y (6) que para cualquiera de estos conjuntos
<span class="math align-center">$P_i$</span>, tendremos que los polígonos llenos serán:</p>
<span class="math align-center">
$$\{p_{ki},p_{(k-2)i},...,\}\in P_F \Rightarrow p_{(k-2m)i}\in P_F:m\in M\subset\mathbb{N},$$
</span> 
mientras que los polígonos huecos serían:  
<span class="math align-center">
$$\{p_{(k-1)i},p_{(k-3)i},...,\}\in P_H \Rightarrow p_{(k-1-2m)i}\in P_H: m\in M'\subset\mathbb{N}.$$
</span>

    </div>
</div>
<p>El código para poder realizar las transformaciones pertinentes y obtener los polígonos con los huecos correspondientes, es el siguiente:</p>

<div class="tab-panel">
  <div class="tab-nav">
    <button
      data-tab-item="sp"
      data-tab-group="default"
      class="tab-nav-button direction-ltr active"
      onclick="switchTab('default','sp')"
      ><span>sp</span></button>
  </div>
  <div class="tab-content">
    <div data-tab-item="sp" data-tab-group="default" class="tab-item active">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">CompleteOrderedSetsFromSpatialPolygonsClass</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">SPDINLABoundaryList</span> <span class="o">&lt;-</span> <span class="nf">list</span><span class="p">(</span><span class="n">Polygons</span><span class="o">=</span><span class="nf">list</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">                              <span class="n">DFIDArea</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">ncol</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="n">nrow</span><span class="o">=</span><span class="m">0</span><span class="p">,</span> <span class="n">dimnames</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="kc">NULL</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="s">&#34;ID&#34;</span><span class="p">,</span> <span class="s">&#34;Area&#34;</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">Polygons[[i]]</span> <span class="o">&lt;-</span> <span class="n">SPDINLAnonconvexBoundary[i]</span>
</span></span><span class="line"><span class="cl">    <span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">DFIDArea[i</span><span class="p">,</span><span class="n">]</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">SPDINLAnonconvexBoundary[i]</span><span class="o">@</span><span class="n">polygons[[1]]</span><span class="o">@</span><span class="n">area</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">IndexIDV</span> <span class="o">&lt;-</span> <span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">DFIDArea</span><span class="o">$</span><span class="n">ID</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">ConnectivityMatrix</span> <span class="o">&lt;-</span> <span class="nf">matrix</span><span class="p">(</span><span class="n">ncol</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">for</span><span class="p">(</span><span class="n">j</span> <span class="n">in</span> <span class="n">i</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">      <span class="n">ConnectivityMatrix[i</span><span class="p">,</span><span class="n">j]</span> <span class="o">&lt;-</span> <span class="n">ConnectivityMatrix[j</span><span class="p">,</span><span class="n">i]</span> <span class="o">&lt;-</span> <span class="nf">as.numeric</span><span class="p">(</span><span class="nf">gIntersects</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary[i]</span><span class="p">,</span> <span class="n">SPDINLAnonconvexBoundary[j]</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">IndexIsolatedPolygonFill</span> <span class="o">&lt;-</span> <span class="nf">which</span><span class="p">(</span><span class="nf">apply</span><span class="p">(</span><span class="n">ConnectivityMatrix</span><span class="p">,</span> <span class="n">FUN</span><span class="o">=</span><span class="n">sum</span><span class="p">,</span> <span class="n">MARGIN</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="o">==</span><span class="m">1</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">IndexIDV</span> <span class="o">&lt;-</span> <span class="nf">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">IndexIsolatedPolygonFill</span><span class="p">)</span><span class="o">==</span><span class="m">0</span><span class="p">){</span><span class="n">IndexIDV</span><span class="p">}</span> <span class="n">else</span><span class="p">{</span><span class="n">IndexIDV[</span><span class="o">-</span><span class="nf">which</span><span class="p">(</span><span class="nf">apply</span><span class="p">(</span><span class="n">ConnectivityMatrix</span><span class="p">,</span> <span class="n">FUN</span><span class="o">=</span><span class="n">sum</span><span class="p">,</span> <span class="n">MARGIN</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="o">==</span><span class="m">1</span><span class="p">)</span><span class="n">]</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">CompleteOrderedSets</span> <span class="o">&lt;-</span> <span class="nf">list</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">=</span><span class="nf">list</span><span class="p">(),</span> <span class="n">DFCompleteOrderedSets</span><span class="o">=</span><span class="nf">list</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">                              <span class="n">CompleteOrderedIsolatedSets</span><span class="o">=</span><span class="nf">list</span><span class="p">(),</span> <span class="n">DFCompleteOrderedIsolatedSets</span><span class="o">=</span><span class="nf">list</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="nf">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">IndexIsolatedPolygonFill</span><span class="p">)</span><span class="o">!=</span><span class="m">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">IndexIsolatedPolygonFill</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">      <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedIsolatedSets[[i]]</span> <span class="o">&lt;-</span> <span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">Polygons[[IndexIsolatedPolygonFill[i]]]</span>
</span></span><span class="line"><span class="cl">      <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedIsolatedSets[[i]]</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">data.frame</span><span class="p">(</span><span class="n">ID</span><span class="o">=</span><span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">Polygons[[IndexIsolatedPolygonFill[i]]]</span><span class="o">@</span><span class="n">polygons[[1]]</span><span class="o">@</span><span class="n">ID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">Area</span><span class="o">=</span><span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">Polygons[[IndexIsolatedPolygonFill[i]]]</span><span class="o">@</span><span class="n">polygons[[1]]</span><span class="o">@</span><span class="n">area</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">HOLE</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="nf">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">IndexIsolatedPolygonFill</span><span class="p">)</span><span class="o">!=</span><span class="nf">length</span><span class="p">(</span><span class="n">IndexIDV</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_step</span> <span class="o">&lt;-</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">while</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">IndexIDV</span><span class="p">)</span><span class="o">!=</span><span class="m">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">IDminArea</span> <span class="o">&lt;-</span> <span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">DFIDArea[IndexIDV</span><span class="p">,</span><span class="s">&#34;ID&#34;</span><span class="n">]</span><span class="nf">[which.min</span><span class="p">(</span><span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">DFIDArea[IndexIDV</span><span class="p">,</span><span class="s">&#34;Area&#34;</span><span class="n">]</span><span class="p">)</span><span class="n">]</span> 
</span></span><span class="line"><span class="cl">      <span class="n">IndxCOS</span> <span class="o">&lt;-</span> <span class="nf">which</span><span class="p">(</span><span class="nf">as.logical</span><span class="p">(</span><span class="n">ConnectivityMatrix[IDminArea</span><span class="p">,</span><span class="n">]</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">DFIDAreaV</span> <span class="o">&lt;-</span> <span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">DFIDArea[IndxCOS</span><span class="p">,</span><span class="n">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[n_step]]</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">sapply</span><span class="p">(</span><span class="n">DFIDAreaV</span><span class="nf">[order</span><span class="p">(</span><span class="n">DFIDAreaV</span><span class="o">$</span><span class="n">Area</span><span class="p">,</span> <span class="n">decreasing</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">),</span><span class="s">&#34;ID&#34;</span><span class="n">]</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                                 <span class="nf">list</span><span class="p">(</span><span class="n">SPDINLABoundaryList</span><span class="o">$</span><span class="n">Polygons[[i]]</span><span class="o">@</span><span class="n">polygons[[1]]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                               <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[n_step]]</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">data.frame</span><span class="p">(</span><span class="n">ID</span><span class="o">=</span><span class="n">DFIDAreaV</span><span class="nf">[order</span><span class="p">(</span><span class="n">DFIDAreaV</span><span class="o">$</span><span class="n">Area</span><span class="p">,</span> <span class="n">decreasing</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">),</span><span class="s">&#34;ID&#34;</span><span class="n">]</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">Area</span><span class="o">=</span><span class="n">DFIDAreaV</span><span class="nf">[order</span><span class="p">(</span><span class="n">DFIDAreaV</span><span class="o">$</span><span class="n">Area</span><span class="p">,</span> <span class="n">decreasing</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">),</span><span class="s">&#34;Area&#34;</span><span class="n">]</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">HOLE</span><span class="o">=</span><span class="nf">floor</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">IndxCOS</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="o">==</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">IndxCOS</span><span class="p">)</span><span class="o">/</span><span class="m">2</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="n">IndexIDV</span> <span class="o">&lt;-</span> <span class="nf">setdiff</span><span class="p">(</span><span class="n">IndexIDV</span><span class="p">,</span><span class="n">IndxCOS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">n_step</span> <span class="o">&lt;-</span> <span class="n">n_step</span><span class="m">+1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">SpatialPolygonsNames</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="o">!=</span><span class="nf">floor</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpatialPolygonsNames</span> <span class="o">&lt;-</span> 
</span></span><span class="line"><span class="cl">          <span class="nf">c</span><span class="p">(</span><span class="n">SpatialPolygonsNames</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="nf">paste0</span><span class="p">(</span><span class="s">&#34;SPDINLA&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                   <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID</span><span class="nf">[length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="p">)</span><span class="n">]</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nf">assign</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="s">&#34;SPDINLA&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID</span><span class="nf">[length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="p">)</span><span class="n">]</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">               <span class="n">value</span><span class="o">=</span><span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                 <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="o">@</span><span class="n">polygons[</span><span class="nf">[length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="p">)</span><span class="n">]]</span>
</span></span><span class="line"><span class="cl">               <span class="p">)))</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="nf">for</span><span class="p">(</span><span class="n">j</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">floor</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="n">indx</span> <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">2+2</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="m">-1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">if</span><span class="p">(</span><span class="nf">exists</span><span class="p">(</span><span class="nf">paste0</span><span class="p">(</span><span class="s">&#34;SPDINLA&#34;</span><span class="p">,</span> <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID[indx[1]]</span><span class="p">))){</span>
</span></span><span class="line"><span class="cl">          <span class="nf">assign</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="s">&#34;SPDINLA&#34;</span><span class="p">,</span> <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID[indx[1]]</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                 <span class="n">value</span><span class="o">=</span><span class="nf">gDifference</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="nf">parse</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="s">&#34;SPDINLA&#34;</span><span class="p">,</span> <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID[indx[1]]</span><span class="p">))),</span> 
</span></span><span class="line"><span class="cl">                                   <span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="o">@</span><span class="n">polygons[[indx[2]]]</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">id</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID[indx[1]]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                 <span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="n">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">SpatialPolygonsNames</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="n">SpatialPolygonsNames</span><span class="p">,</span> <span class="nf">paste0</span><span class="p">(</span><span class="s">&#34;SPDINLA&#34;</span><span class="p">,</span> <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID[indx[1]]</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">          <span class="nf">assign</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="s">&#34;SPDINLA&#34;</span><span class="p">,</span> <span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID[indx[1]]</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                 <span class="n">value</span><span class="o">=</span><span class="nf">gDifference</span><span class="p">(</span><span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="o">@</span><span class="n">polygons[[indx[1]]]</span><span class="p">)),</span> 
</span></span><span class="line"><span class="cl">                                   <span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedSets[[i]]</span><span class="o">@</span><span class="n">polygons[[indx[2]]]</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">id</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">DFCompleteOrderedSets[[i]]</span><span class="o">$</span><span class="n">ID[indx[1]]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                 <span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}}</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="nf">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">IndexIsolatedPolygonFill</span><span class="p">)</span><span class="o">!=</span><span class="m">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpatialPolygonRefined</span> <span class="o">&lt;-</span> <span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="nf">lapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">SpatialPolygonsNames</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="nf">return</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="nf">parse</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="n">SpatialPolygonsNames[i]</span><span class="p">,</span> <span class="s">&#34;@polygons[[1]]&#34;</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}),</span> <span class="nf">lapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedIsolatedSets</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="nf">return</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedIsolatedSets[[i]]</span><span class="o">@</span><span class="n">polygons[[1]]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">})))</span>        
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="n">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpatialPolygonRefined</span> <span class="o">&lt;-</span> <span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">lapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">SpatialPolygonsNames</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="nf">return</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="nf">parse</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span><span class="n">SpatialPolygonsNames[i]</span><span class="p">,</span> <span class="s">&#34;@polygons[[1]]&#34;</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}))</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SpatialPolygonRefined</span> <span class="o">&lt;-</span> <span class="nf">SpatialPolygons</span><span class="p">(</span><span class="nf">lapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedIsolatedSets</span><span class="p">),</span> <span class="nf">function</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">return</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">$</span><span class="n">CompleteOrderedIsolatedSets[[i]]</span><span class="o">@</span><span class="n">polygons[[1]]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}))</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">SpatialPolygonRefined</span><span class="o">@</span><span class="n">proj4string</span> <span class="o">&lt;-</span> <span class="nf">CRS</span><span class="p">(</span><span class="s">&#34;+proj=utm&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">CompleteOrderedSetsAndPolygons</span> <span class="o">&lt;-</span> <span class="nf">list</span><span class="p">(</span><span class="n">CompleteOrderedSets</span><span class="o">=</span><span class="n">CompleteOrderedSets</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">SpatialPolygonRefined</span><span class="o">=</span><span class="n">SpatialPolygonRefined</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="nf">return</span><span class="p">(</span><span class="n">CompleteOrderedSetsAndPolygons</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
    </div>
  </div>
</div>
<p>Gracias a esta función tenemos todos los polígonos según las curvas cerradas que los determinan. Esto permite que se puedan realizar operaciones mediante ellos, de tal forma que se esté teniendo en cuenta los huecos existentes.</p>
<p>Por tanto, siguiendo el ejemplo, tendríamos que aplicar la primera función <code>SpatialPolygonsBoundary</code> sobre el resultado de la malla <code>INLAnonconvexMesh</code>, y posteriormente aplicar la función que acabamos de definir.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">SPDINLAnonconvexBoundary</span> <span class="o">&lt;-</span> <span class="nf">SpatialPolygonsBoundary</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">INLAnonconvexMesh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">PolygonsRefined</span> <span class="o">&lt;-</span> <span class="nf">CompleteOrderedSetsFromSpatialPolygonsClass</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span> <span class="o">=</span> <span class="n">SPDINLAnonconvexBoundary</span><span class="p">)</span>
</span></span></code></pre></div><p>Para que se visualice que propiamente ahora tenemos la totalidad de los polígonos disponibles unos independientes de otros, podemos graficarlos mediante diferentes colores:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">col</span> <span class="o">&lt;-</span> <span class="n">viridis</span><span class="o">::</span><span class="nf">turbo</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">PolygonsRefined</span><span class="o">$</span><span class="n">SpatialPolygonRefined</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">ggplotPolygons</span> <span class="o">&lt;-</span> <span class="nf">ggplot</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">PolygonsRefined</span><span class="o">$</span><span class="n">SpatialPolygonRefined</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="n">ggplotPolygons</span> <span class="o">&lt;-</span> <span class="n">ggplotPolygons</span> <span class="o">+</span> <span class="nf">geom_sf</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">st_as_sf</span><span class="p">(</span><span class="n">PolygonsRefined</span><span class="o">$</span><span class="n">SpatialPolygonRefined[i]</span><span class="p">),</span> <span class="n">fill</span><span class="o">=</span><span class="n">col[i]</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="m">0.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Tal que, si representamos los polígonos como <code>ggplotPolygons + theme_void()</code> obtendremos la siguiente figura:</p>
<table>
<thead>
<tr>
<th style="text-align:center"><b>Fig. 2: Refined polygons</b></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
		
<a href="../../es/inla/variousfunctions/inlatosp/ggplotPolygonsRefined.png?&amp;width=25pc" data-featherlight="image">
<img src="../../es/inla/variousfunctions/inlatosp/ggplotPolygonsRefined.png?&amp;width=25pc" alt="Polygons_with_holes" style="height: auto; width: 25pc;" loading="lazy">
</a></td>
</tr>
</tbody>
</table>

<div class="expand">
    <a class="expand-label" onclick="$t=$(this); if($t.parent('.expand-expanded.expand-marked').length){ $t.next().css('display','none') }else if($t.parent('.expand-marked').length){ $t.next().css('display','block') }else{ $t.next('.expand-content').slideToggle(100); } $t.parent().toggleClass('expand-expanded');">
        <i class="fas fa-chevron-down"></i>
        <i class="fas fa-chevron-left expand-rtl direction-ltr"></i>
        <i class="fas fa-chevron-right expand-ltr direction-ltr"></i>
        Ejemplo con polígonos apilados.
    </a>
    <div class="expand-content" style="display: none;">
<p>Vamos a presentar un pequeño ejemplo para que se visualice que la función es capaz de extraer un orden arbitrario de polígonos, aunque estos estén apilados. Es decir, en principio, la función aplica para cualquier caso en general que cumpla con dos condiciones, (i) la <em>intersección total</em> y (ii) la ordenación de <em>polígono-lleno</em> / <em>polígono-hueco</em> en niveles sucesivos de <em>intersección máxima interna</em>.</p>
<p>Lo primero que haremos para comprobar que dicha función es capaz de operar con polígonos apilados será crear los polígonos:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">rho1</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="m">120</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0.01</span><span class="p">);</span> <span class="n">theta1</span> <span class="o">&lt;-</span> <span class="nf">runif</span><span class="p">(</span><span class="m">120</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="o">*</span><span class="kc">pi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">rho2</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="m">120</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">0.01</span><span class="p">);</span> <span class="n">theta2</span> <span class="o">&lt;-</span> <span class="nf">runif</span><span class="p">(</span><span class="m">120</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="o">*</span><span class="kc">pi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">rho3</span> <span class="o">&lt;-</span> <span class="nf">rnorm</span><span class="p">(</span><span class="m">220</span><span class="p">,</span><span class="m">12</span><span class="p">,</span><span class="m">0.01</span><span class="p">);</span> <span class="n">theta3</span> <span class="o">&lt;-</span> <span class="nf">runif</span><span class="p">(</span><span class="m">220</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="o">*</span><span class="kc">pi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">XYPoint</span> <span class="o">&lt;-</span> <span class="nf">as.matrix</span><span class="p">(</span><span class="nf">rbind</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cbind</span><span class="p">(</span><span class="n">rho1</span><span class="o">*</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span> <span class="n">rho1</span><span class="o">*</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cbind</span><span class="p">(</span><span class="n">rho2</span><span class="o">*</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">),</span> <span class="n">rho2</span><span class="o">*</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cbind</span><span class="p">(</span><span class="n">rho3</span><span class="o">*</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta3</span><span class="p">),</span> <span class="n">rho3</span><span class="o">*</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta3</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Boundary</span> <span class="o">&lt;-</span> <span class="nf">inla.nonconvex.hull</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">XYPoint</span><span class="p">,</span> <span class="n">convex</span><span class="o">=</span><span class="m">1</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">100</span><span class="p">,</span><span class="m">100</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">INLAnonconvexMesh</span> <span class="o">&lt;-</span> <span class="nf">inla.mesh.2d</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="n">Boundary</span><span class="p">,</span> <span class="n">max.edge</span><span class="o">=</span><span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">SPDINLAnonconvexBoundary</span> <span class="o">&lt;-</span> <span class="nf">SpatialPolygonsBoundary</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">INLAnonconvexMesh</span><span class="p">)</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:center"><b>Fig. 3: Nested polygons</b></th>
<th style="text-align:center"><b>Fig. 4: Mesh of nested polygons</b></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
		
<a href="../../es/inla/variousfunctions/inlatosp/ggplotTest.png?&amp;width=25pc" data-featherlight="image">
<img src="../../es/inla/variousfunctions/inlatosp/ggplotTest.png?&amp;width=25pc" alt="Nested_polygons" style="height: auto; width: 25pc;" loading="lazy">
</a></td>
<td style="text-align:center">
		
<a href="../../es/inla/variousfunctions/inlatosp/ggTestMesh.png?&amp;width=25pc" data-featherlight="image">
<img src="../../es/inla/variousfunctions/inlatosp/ggTestMesh.png?&amp;width=25pc" alt="Mesh_nested_polygons" style="height: auto; width: 25pc;" loading="lazy">
</a></td>
</tr>
</tbody>
</table>
<p>A continuación aplicacamos la función para extraer los polígonos con los huecos y representamos gráficamente el resultado:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-r" data-lang="r"><span class="line"><span class="cl"><span class="n">PolygonsRefined</span> <span class="o">&lt;-</span> <span class="nf">CompleteOrderedSetsFromSpatialPolygonsClass</span><span class="p">(</span><span class="n">SPDINLAnonconvexBoundary</span><span class="o">=</span><span class="n">SPDINLAnonconvexBoundary</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">col</span> <span class="o">&lt;-</span> <span class="n">viridis</span><span class="o">::</span><span class="nf">turbo</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">PolygonsRefined</span><span class="o">$</span><span class="n">SpatialPolygonRefined</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">ggplotPolygons</span> <span class="o">&lt;-</span> <span class="nf">ggplot</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">PolygonsRefined</span><span class="o">$</span><span class="n">SpatialPolygonRefined</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">  <span class="n">ggplotPolygons</span> <span class="o">&lt;-</span> <span class="n">ggplotPolygons</span> <span class="o">+</span> <span class="nf">geom_sf</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">st_as_sf</span><span class="p">(</span><span class="n">PolygonsRefined</span><span class="o">$</span><span class="n">SpatialPolygonRefined[i]</span><span class="p">),</span> <span class="n">fill</span><span class="o">=</span><span class="n">col[i]</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="m">0.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:center"><b>Fig. 5: Nested polygons fixing holes</b></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
		
<a href="../../es/inla/variousfunctions/inlatosp/ggplotTestFixed.png?&amp;width=25pc" data-featherlight="image">
<img src="../../es/inla/variousfunctions/inlatosp/ggplotTestFixed.png?&amp;width=25pc" alt="Nested_polygons" style="height: auto; width: 25pc;" loading="lazy">
</a></td>
</tr>
</tbody>
</table>

    </div>
</div>

            <footer class="footline">
            </footer>
          </article>

          </section>
          <article class="default">
<h1 id="modelos-espaciales-spde-fem">Modelos Espaciales (SPDE-FEM)</h1>

<p>En esta sección expondremos cómo realizar distintos tipos de modelos espaciales con INLA en el entorno <strong>R-INLA</strong>:</p>

<ul class="children children-li children-sort-weight">
	
<li><a href="../../es/inla/spatialmodels/geostatisticalmodel/index.html">Modelo Geoestadístico</a><p>Un modelo geoestadístico simple en INLA.</p></li>
<li><a href="../../es/inla/spatialmodels/jointmodel_preferential/index.html">Modelo Preferencial</a><p>Un modelo conjunto para datos prefenciales.</p></li>
<li><a href="../../es/inla/spatialmodels/spatialvaryingcoefficientmodel/index.html">Modelo SVC</a><p>Modelos de Coeficientes Espacialmente Variables.</p></li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsecciones de Modelos Espaciales (SPDE-FEM)</h1>
          <article class="default">
<h1 id="modelo-geoestad%C3%ADstico">Modelo Geoestadístico</h1>

<p>En esta sección expondremos</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
<h1 id="modelo-preferencial">Modelo Preferencial</h1>

<p>In this section we will show</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
<h1 id="modelo-svc">Modelo SVC</h1>

<p>En esta sección expondremos cómo realizar distintos tipos de modelos espaciales con INLA en el entonrno <strong>R-INLA</strong>:</p>

<ul class="children children-li children-sort-weight">
	
</ul>

            <footer class="footline">
            </footer>
          </article>

          </section>
          </section>        </div>
      </main>
    </div>
    <script src="../../js/clipboard.min.js" defer></script>
    <script src="../../js/perfect-scrollbar.min.js" defer></script>
    <script src="../../js/featherlight.min.js" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../js/mathjax/tex-mml-chtml.js"></script>
    <script src="../../js/jquery.svg.pan.zoom.js" defer></script>
    <script src="../../js/mermaid.min.js" defer></script>
    <script>
      window.themeUseMermaid = JSON.parse("{ \"securityLevel\": \"loose\" }");
    </script>
    <script src="../../js/theme.js" defer></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-105947713-1', 'auto');
  ga('send', 'pageview');

</script>
  </body>
</html>
